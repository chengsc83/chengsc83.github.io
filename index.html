<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è¾¯æ™‚è¨ˆ</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.15.0/Sortable.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');

        :root {
            --font-primary: 'Inter', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            
            /* Light Mode (Default) */
            --color-bg-page: #F3F4F6; 
            --color-bg-container: #FFFFFF;
            --color-bg-alt: #F9FAFB; 
            --color-bg-info: #E0F2FE; 
            --color-bg-modal-overlay: rgba(0,0,0,0.6);

            --color-text-primary: #1F2937; 
            --color-text-secondary: #374151; 
            --color-text-muted: #6B7280; 
            --color-text-on-primary: #FFFFFF;
            --color-text-on-warning: #1F2937; 

            --color-primary: #3B82F6; 
            --color-primary-dark: #2563EB; 
            --color-primary-light: #BFDBFE; 
            
            --color-secondary: #6B7280; 
            --color-secondary-dark: #4B5563; 

            --color-success: #10B981; 
            --color-success-dark: #059669; 

            --color-warning: #F59E0B; 
            --color-warning-dark: #D97706; 
            
            --color-danger: #EF4444; 
            --color-danger-dark: #DC2626; 

            --color-orange-accent: #F97316; 
            --color-orange-accent-dark: #EA580C; 

            --color-border: #D1D5DB; 
            --color-border-light: #E5E7EB; 
            --color-border-input-focus: var(--color-primary);

            --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
            --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.07), 0 2px 4px -2px rgba(0, 0, 0, 0.07);
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.08), 0 4px 6px -4px rgba(0, 0, 0, 0.08);

            --border-radius-sm: 4px;
            --border-radius-md: 6px;
            --border-radius-lg: 8px;

            --transition-fast: all 0.2s ease-in-out;
            --transition-base: all 0.3s ease-in-out;

            --color-input-bg: #FFFFFF;
            --color-input-text: #1F2937;
            --color-input-border: var(--color-border);
        }

        body.dark-mode {
            --color-bg-page: #1A202C; 
            --color-bg-container: #2D3748; 
            --color-bg-alt: #1F2937; 
            --color-bg-info: #2C5282; 
            --color-bg-modal-overlay: rgba(0,0,0,0.75);

            --color-text-primary: #F7FAFC; 
            --color-text-secondary: #E2E8F0; 
            --color-text-muted: #A0AEC0; 
            
            --color-primary-light: #63B3ED; 

            --color-border: #4A5568; 
            --color-border-light: #2D3748; 

            --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.15); 
            --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.18), 0 2px 4px -2px rgba(0, 0, 0, 0.15);
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.2), 0 4px 6px -4px rgba(0, 0, 0, 0.18);
            
            --color-input-bg: #1F2937; 
            --color-input-text: #F7FAFC; 
            --color-input-border: #4A5568; 
        }


        body { 
            font-family: var(--font-primary); 
            margin: 0; 
            padding: 20px 0 40px 0; 
            background-color: var(--color-bg-page); 
            color: var(--color-text-primary); 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            min-height: 100vh; 
            box-sizing: border-box; 
            transition: background-color var(--transition-base), color var(--transition-base); 
        }

        .container { 
            background-color: var(--color-bg-container); 
            padding: 25px 35px 35px 35px; 
            border-radius: var(--border-radius-lg); 
            box-shadow: var(--shadow-lg); 
            width: 90%; 
            max-width: 800px; 
            text-align: center; 
            transition: var(--transition-base); 
            margin-bottom: 20px; 
        }

        #themeToggleButton {
            background-color: var(--color-secondary);
            color: var(--color-text-on-primary);
            border: 1px solid var(--color-secondary-dark);
            padding: 8px 15px;
            border-radius: var(--border-radius-md);
            cursor: pointer;
            font-size: 0.85em;
            margin-bottom: 20px;
            transition: var(--transition-fast);
        }
        #themeToggleButton:hover {
            background-color: var(--color-secondary-dark);
        }
        body.dark-mode #themeToggleButton {
             background-color: var(--color-primary-light); 
             color: var(--color-text-primary); 
             border-color: var(--color-primary);
        }
         body.dark-mode #themeToggleButton:hover {
             background-color: var(--color-primary);
             color: var(--color-text-on-primary);
        }


        h1 { 
            color: var(--color-primary); 
            margin-bottom: 20px; 
            font-size: 2em; 
            font-weight: 600;
        }
        h2 {
            font-weight: 600;
            color: var(--color-text-primary);
            margin-top: 1.5em;
            margin-bottom: 0.8em;
        }
        h3 {
            font-weight: 600;
            color: var(--color-text-secondary);
        }
         h4 {
            font-weight: 500;
            color: var(--color-text-secondary);
            margin-top: 1em;
            margin-bottom: 0.5em;
        }


        .debate-info { 
            background-color: var(--color-bg-info); 
            padding: 12px 18px; 
            border-radius: var(--border-radius-md); 
            margin-bottom: 20px; 
            font-size: 0.95em; 
            border: 1px solid var(--color-primary-light); 
            text-align: left; 
            transition: var(--transition-base); 
        }
        .debate-info p { margin: 6px 0; } 
        .debate-info strong { color: var(--color-primary-dark); font-weight: 600; }
        body.dark-mode .debate-info strong { color: var(--color-primary-light); }


        #moderatorScript { 
            font-size: 1.2em; 
            color: var(--color-text-secondary); 
            margin-bottom: 20px; 
            padding: 18px; 
            border: 1px solid var(--color-border-light); 
            border-radius: var(--border-radius-md); 
            background-color: var(--color-bg-alt); 
            min-height: 70px; 
            line-height: 1.6; 
            text-align: left; 
            transition: var(--transition-base); 
        }

        #timerDisplay { 
            font-size: 3em; 
            font-weight: 700; 
            color: var(--color-primary); 
            margin-bottom: 10px; 
            padding: 12px 15px; 
            border: 2px dashed var(--color-primary-light); 
            border-radius: var(--border-radius-lg); 
            background-color: var(--color-bg-alt); 
            transition: var(--transition-base); 
        }
        
        #timerProgressBarContainer {
            width: 100%;
            height: 20px; 
            background-color: var(--color-border-light); 
            border-radius: var(--border-radius-sm);
            margin-top: 5px; 
            margin-bottom: 15px; 
            overflow: hidden; 
        }
        #timerProgressBar {
            width: 0%; 
            height: 100%;
            background-color: var(--color-primary); 
            border-radius: var(--border-radius-sm);
            transition: width 0.5s ease-out, background-color var(--transition-fast); 
        }
        
        #timerStatus, #drawResultDisplay, #fileImportStatus { 
            font-size: 0.9em; 
            color: var(--color-text-muted); 
            margin-bottom: 10px; 
            min-height: 1.2em; 
            font-weight: 500; 
            transition: color var(--transition-base); 
        }
        
        #nextSegmentPreview {
            font-size: 1em;
            color: var(--color-text-secondary);
            margin-top: 10px;
            margin-bottom: 15px;
            padding: 8px 12px;
            border: 1px dashed var(--color-border-light);
            border-radius: var(--border-radius-md);
            background-color: var(--color-bg-alt);
            min-height: 1.5em; 
            transition: var(--transition-base);
        }

        button, .controls button, .setup-controls button, .draw-controls button, .timer-actions button, .flow-io button, .editor-controls button { 
            background-color: var(--color-primary); 
            color: var(--color-text-on-primary); 
            border: none; 
            padding: 10px 18px; 
            text-align: center; 
            text-decoration: none; 
            display: inline-block; 
            font-size: 0.9em; 
            font-weight: 500; 
            margin: 5px 4px; 
            cursor: pointer; 
            border-radius: var(--border-radius-md); 
            transition: background-color var(--transition-fast), transform var(--transition-fast), box-shadow var(--transition-fast);
            box-shadow: var(--shadow-sm);
        }
        button:hover, .controls button:hover, .setup-controls button:hover, .draw-controls button:hover, .timer-actions button:hover, .flow-io button:hover, .editor-controls button:hover { 
            background-color: var(--color-primary-dark); 
            box-shadow: var(--shadow-md);
        }
        button:active, .controls button:active, .setup-controls button:active, .draw-controls button:active, .timer-actions button:active, .flow-io button:active, .editor-controls button:active { 
            transform: scale(0.97); 
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
        }
        button:disabled, .controls button:disabled, .setup-controls button:disabled, .draw-controls button:disabled, .timer-actions button:disabled, .flow-io button:disabled, .editor-controls button:disabled { 
            background-color: #B0B0B0; 
            color: #F0F0F0;
            cursor: not-allowed; 
            box-shadow: none;
            transform: scale(1);
        }
        body.dark-mode button:disabled, body.dark-mode .controls button:disabled, 
        body.dark-mode .setup-controls button:disabled, body.dark-mode .draw-controls button:disabled, 
        body.dark-mode .timer-actions button:disabled, body.dark-mode .flow-io button:disabled, 
        body.dark-mode .editor-controls button:disabled {
            background-color: #4A5568; 
            color: #718096; 
        }


        .manual-override-button, .skip-button { 
            background-color: var(--color-warning) !important; 
            color: var(--color-text-on-warning) !important; 
        }
        .manual-override-button:hover, .skip-button:hover { 
            background-color: var(--color-warning-dark) !important; 
        }
        /* Specific button styling for editor actions */
        .editor-controls button.edit, .editor-controls .more-actions-dropdown button.insert-before {
            background-color: var(--color-warning) !important; 
            color: var(--color-text-on-warning) !important; 
        }
        .editor-controls button.edit:hover, .editor-controls .more-actions-dropdown button.insert-before:hover {
            background-color: var(--color-warning-dark) !important; 
        }


        .pause-resume-button { 
            background-color: var(--color-orange-accent) !important; 
            color: var(--color-text-on-primary) !important;
        }
        .pause-resume-button:hover { 
            background-color: var(--color-orange-accent-dark) !important; 
        }

        .draw-controls button, #finishEditingButton, .editor-controls .more-actions-dropdown button.duplicate { 
            background-color: var(--color-success) !important; 
        } 
        .draw-controls button:hover, #finishEditingButton:hover, .editor-controls .more-actions-dropdown button.duplicate:hover { 
            background-color: var(--color-success-dark) !important; 
        }

        .flow-io button, #cancelEditingButton, .editor-controls .more-actions-btn, .editor-controls .more-actions-dropdown button.move {
            background-color: var(--color-secondary) !important; 
        } 
        .flow-io button:hover, #cancelEditingButton:hover, .editor-controls .more-actions-btn:hover, .editor-controls .more-actions-dropdown button.move:hover {
            background-color: var(--color-secondary-dark) !important; 
        }
        
        .editor-controls button.delete { 
            background-color: var(--color-danger) !important; 
        } 
        .editor-controls button.delete:hover { 
            background-color: var(--color-danger-dark) !important; 
        }
        
        .info { 
            margin-top: 20px; 
            font-size: 0.85em; 
            color: var(--color-text-muted); 
            transition: color var(--transition-base); 
        }
        #currentStageInfo { 
            font-size: 1.1em; 
            font-weight: 600; 
            color: var(--color-text-secondary); 
            margin-bottom: 12px; 
            transition: var(--transition-base); 
        }
        .hidden { display: none !important; }

        #speechRecognitionStatus { 
            margin-top: 8px; 
            font-style: italic; 
            color: var(--color-text-muted); 
            font-size: 0.85em; 
            min-height: 1.1em; 
            transition: color var(--transition-base); 
        }

        .setup-section, .draw-section, .flow-io-section, #flowEditorSection { 
            margin-bottom: 20px; 
            padding: 18px; 
            border: 1px solid var(--color-border-light); 
            border-radius: var(--border-radius-lg); 
            background-color: var(--color-bg-alt);
            transition: background-color var(--transition-base), border-color var(--transition-base); 
        }
        .setup-section label, .modal-content fieldset legend { 
            display: block; 
            margin-top: 10px; 
            margin-bottom: 5px; 
            font-weight: 500; 
            text-align: left; 
            color: var(--color-text-secondary);
            transition: color var(--transition-base); 
        }
        .modal-content fieldset {
            border: 1px solid var(--color-border-light);
            border-radius: var(--border-radius-md);
            padding: 10px 15px 15px 15px;
            margin-top: 15px;
            margin-bottom: 10px;
        }
        body.dark-mode .modal-content fieldset {
             border-color: var(--color-border);
        }
        .modal-content fieldset legend {
            padding: 0 5px;
            font-size: 0.95em;
            font-weight: 600;
        }

        .setup-section input[type="text"], .setup-section select,
        .modal-content input[type="text"], .modal-content input[type="number"], 
        .modal-content select, .modal-content textarea { 
            width: calc(100% - 24px); 
            padding: 10px 12px; 
            border: 1px solid var(--color-input-border); 
            border-radius: var(--border-radius-md); 
            box-sizing: border-box; 
            margin-bottom: 8px; 
            font-family: var(--font-primary);
            font-size: 0.95em;
            color: var(--color-input-text);
            background-color: var(--color-input-bg);
            transition: border-color var(--transition-fast), box-shadow var(--transition-fast), background-color var(--transition-base), color var(--transition-base);
        }
        .setup-section input[type="text"]:focus, .setup-section select:focus,
        .modal-content input[type="text"]:focus, .modal-content input[type="number"]:focus, 
        .modal-content select:focus, .modal-content textarea:focus {
            border-color: var(--color-border-input-focus);
            box-shadow: 0 0 0 2px var(--color-primary-light);
            outline: none;
        }

        .flow-io-section input[type="file"] { 
            margin-top: 8px; 
            display: block; 
            margin-left: auto; 
            margin-right: auto; 
            padding: 5px;
            border: 1px solid var(--color-input-border);
            background-color: var(--color-input-bg); 
            color: var(--color-input-text);
            border-radius: var(--border-radius-md);
            font-size: 0.9em;
        }
         body.dark-mode .flow-io-section input[type="file"]::file-selector-button {
            background-color: var(--color-secondary);
            color: var(--color-text-on-primary);
            border: none;
            padding: 5px 10px;
            border-radius: var(--border-radius-sm);
            cursor: pointer;
        }


        .timer-actions { 
            margin-top: 10px; 
            margin-bottom: 10px; 
            min-height: 40px; 
            transition: margin var(--transition-base); 
        }
        .debate-controls-wrapper { /* For auto mode toggle positioning */
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap; /* Allow wrapping on small screens */
            margin-top: 10px;
        }
        .debate-controls-wrapper .main-controls {
            display: flex;
            gap: 8px; /* Space between main control buttons */
            flex-wrap: wrap;
        }
        .debate-controls-wrapper .auto-mode-control {
            margin-top: 5px; /* Space above if it wraps */
            font-size: 0.9em;
            color: var(--color-text-secondary);
        }
        .debate-controls-wrapper .auto-mode-control input {
            margin-right: 5px;
            vertical-align: middle;
        }


        #flowEditorList { 
            list-style: none; 
            padding: 0; 
            margin-top: 15px; 
        }
        #flowEditorList li { 
            background-color: var(--color-bg-container); 
            border: 1px solid var(--color-border-light); 
            border-radius: var(--border-radius-md); 
            padding: 12px 15px; 
            margin-bottom: 10px; 
            display: flex; 
            justify-content: space-between; 
            align-items: center; 
            cursor: grab; 
            box-shadow: var(--shadow-sm);
            transition: background-color var(--transition-fast), box-shadow var(--transition-fast);
            position: relative; 
        }
        body.dark-mode #flowEditorList li {
            background-color: var(--color-input-bg); 
            border-color: var(--color-border);
        }
        #flowEditorList li:hover {
            background-color: #f0f0f0; 
            box-shadow: var(--shadow-md);
        }
        body.dark-mode #flowEditorList li:hover {
            background-color: #374151; 
        }

        #flowEditorList li:active { 
            cursor: grabbing; 
            background-color: #e9e9e9; 
            box-shadow: var(--shadow-md);
        } 
        body.dark-mode #flowEditorList li:active {
            background-color: #4A5568; 
        }
        #flowEditorList .stage-info { 
            text-align: left; 
            flex-grow: 1; 
            margin-right: 15px; 
            overflow: hidden; 
            display: flex; 
            align-items: center; 
        }
        #flowEditorList .stage-info .stage-icon {
            margin-right: 8px;
            font-size: 1.1em;
            flex-shrink: 0; 
        }
        #flowEditorList .stage-info strong {
            font-weight: 600;
            color: var(--color-text-primary);
        }
        #flowEditorList .stage-info span { 
            display: block; 
            font-size: 0.85em; 
            color: var(--color-text-muted); 
            margin-top: 3px;
            white-space: nowrap; 
            overflow: hidden; 
            text-overflow: ellipsis;
        }
        #flowEditorList .editor-controls { 
            display: flex; 
            flex-wrap: nowrap; 
            gap: 6px; 
            flex-shrink: 0; 
            align-items: center;
        }
        #flowEditorList .editor-controls button { 
            padding: 6px 10px; 
            font-size: 0.8em; 
        }
        .editor-controls .more-actions-container {
            position: relative;
            display: inline-block;
        }
        .editor-controls .more-actions-btn {
            padding: 6px 8px; 
        }

        .editor-controls .more-actions-dropdown {
            display: none; 
            position: absolute;
            right: 0;
            top: calc(100% + 5px); 
            background-color: var(--color-bg-container);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius-md);
            box-shadow: var(--shadow-md);
            z-index: 10;
            min-width: 130px; 
            padding: 5px 0;
        }
        body.dark-mode .editor-controls .more-actions-dropdown {
            background-color: var(--color-bg-alt); 
            border-color: var(--color-input-border);
        }
        .editor-controls .more-actions-dropdown.active {
            display: block;
        }
        .editor-controls .more-actions-dropdown button {
            display: block;
            width: 100%;
            text-align: left;
            padding: 8px 12px;
            margin: 0;
            border: none;
            border-radius: 0;
            background-color: transparent;
            color: var(--color-text-primary);
            font-size: 0.85em;
        }
        .editor-controls .more-actions-dropdown button:hover {
            background-color: var(--color-bg-alt); 
        }
        body.dark-mode .editor-controls .more-actions-dropdown button {
             color: var(--color-text-primary); 
        }
        body.dark-mode .editor-controls .more-actions-dropdown button:hover {
            background-color: var(--color-secondary-dark); 
        }


        .modal { 
            display: none; 
            position: fixed; 
            z-index: 1000; 
            left: 0; 
            top: 0; 
            width: 100%; 
            height: 100%; 
            overflow: auto; 
            background-color: var(--color-bg-modal-overlay); 
            padding-top: 5vh; 
        }
        .modal-content { 
            background-color: var(--color-bg-container); 
            margin: 5% auto; 
            padding: 25px 30px; 
            border: 1px solid var(--color-border); 
            width: 85%; 
            max-width: 600px; 
            border-radius: var(--border-radius-lg); 
            box-shadow: var(--shadow-lg);
            text-align: left; 
        }
        .modal-content h3 { 
            margin-top: 0; 
            margin-bottom: 20px;
            color: var(--color-primary); 
            font-weight: 600;
            font-size: 1.5em;
            text-align: center; 
        }
        .modal-content label { 
            display: block; 
            margin-top: 12px; 
            margin-bottom: 4px;
            font-weight: 500; 
            text-align: left;
            color: var(--color-text-secondary);
        }
        .modal-content textarea { 
            resize: vertical; 
            min-height: 80px; 
        }
        .modal-buttons { 
            text-align: right; 
            margin-top: 25px; 
        }
        .modal-buttons button {
            margin-left: 8px;
        }
        .modal-buttons button[onclick="closeModal()"],
        .modal-buttons button[onclick="closeShortcutHelpModal()"] 
         {
            background-color: var(--color-secondary);
        }
        .modal-buttons button[onclick="closeModal()"]:hover,
        .modal-buttons button[onclick="closeShortcutHelpModal()"]:hover {
            background-color: var(--color-secondary-dark);
        }
        #shortcutHelpList {
            list-style: none;
            padding-left: 0;
        }
        #shortcutHelpList li {
            margin-bottom: 8px;
            font-size: 0.95em;
        }
        #shortcutHelpList li strong {
            display: inline-block;
            width: 130px; 
            color: var(--color-primary);
            font-weight: 600;
        }
        body.dark-mode #shortcutHelpList li strong {
            color: var(--color-primary-light);
        }


        .close-button { 
            color: var(--color-text-muted); 
            float: right; 
            font-size: 28px; 
            font-weight: bold; 
            line-height: 1;
        }
        .close-button:hover, .close-button:focus { 
            color: var(--color-text-primary); 
            text-decoration: none; 
            cursor: pointer; 
        }

        #fullscreenButton { 
            position: fixed; 
            top: 15px; 
            right: 15px; 
            z-index: 1001; 
            padding: 8px 14px; 
            font-size: 0.85em; 
            background-color: var(--color-primary); 
            color: var(--color-text-on-primary); 
            border: none; 
            border-radius: var(--border-radius-md); 
            cursor: pointer; 
            transition: background-color var(--transition-fast); 
            box-shadow: var(--shadow-md);
        }
        #fullscreenButton:hover {
             background-color: var(--color-primary-dark);
        }
        body.fullscreen-active #fullscreenButton { 
            background-color: var(--color-danger); 
        } 
        body.fullscreen-active #fullscreenButton:hover { 
            background-color: var(--color-danger-dark);
        }

        body.fullscreen-active { 
            background-color: #111; 
            color: #eee; 
            overflow: hidden; 
            font-family: var(--font-primary); 
            padding-bottom: 0; 
        }
        body.fullscreen-active .container { 
            width: 100vw; height: 100vh; 
            max-width: none; max-height: none; 
            border-radius: 0; 
            box-shadow: none; 
            background-color: #111; 
            display: flex; flex-direction: column; 
            justify-content: center; align-items: center; 
            padding: 1vh 1vw; 
            box-sizing: border-box; 
            margin-bottom: 0; 
        }
        body.fullscreen-active #debatePhase { 
            display: flex; flex-direction: column; 
            justify-content: space-between; align-items: center; 
            height: 100%; width: 100%; 
            padding: 0; 
        }
        
        body.fullscreen-active #setupPhase,
        body.fullscreen-active #flowEditorSection,
        body.fullscreen-active #drawRebuttalOrderSection,
        body.fullscreen-active .flow-io-section,
        body.fullscreen-active .info,
        body.fullscreen-active #resetButton,
        body.fullscreen-active #manualStartTimerButton,
        body.fullscreen-active #forceStartMainTimerButton,
        body.fullscreen-active #editFlowButton, 
        body.fullscreen-active h1,
        body.fullscreen-active #themeToggleButton 
         { display: none !important; }

        #fullscreenRealTimeClock {
            position: fixed;
            top: 10px; 
            left: 10px; 
            font-size: clamp(14px, 1.8vw, 20px); 
            color: #bbb; 
            z-index: 1002; 
            padding: 5px 8px;
            background-color: rgba(0,0,0,0.4); 
            border-radius: var(--border-radius-sm);
        }
        body:not(.fullscreen-active) #fullscreenRealTimeClock {
            display: none !important;
        }


        body.fullscreen-active #debateInfoDisplay { 
            order: 1; 
            background-color: transparent; 
            border: none; 
            font-size: clamp(14px, 2.2vw, 26px); 
            color: #ccc; 
            text-align: center; 
            margin-bottom: 1vh; 
        }
        body.fullscreen-active #debateInfoDisplay p { margin: 0.3vh 0; }
        body.fullscreen-active #currentStageInfo { 
            order: 2; 
            font-size: clamp(26px, 6vw, 70px); 
            font-weight: 700; 
            color: #f0f0f0; 
            margin-bottom: 2vh; 
            line-height: 1.2;
        }
        body.fullscreen-active #timerDisplay { 
            order: 3; 
            font-size: clamp(70px, 18vw, 200px); 
            font-weight: 700; 
            color: #259DFA; 
            border: none; 
            background-color: transparent; 
            line-height: 1; 
            margin-bottom: 1vh; 
            padding: 0; 
        }
        body.fullscreen-active #timerProgressBarContainer {
            order: 4; 
            width: 80%; 
            max-width: 600px;
            height: 25px; 
            background-color: #444; 
            margin-bottom: 1.5vh;
        }
        body.fullscreen-active #timerProgressBar {
            background-color: #259DFA; 
        }
        body.fullscreen-active #timerDisplay[style*="color: rgb(255, 165, 0)"], 
        body.fullscreen-active #timerDisplay[style*="color: #ffa500"] { color: #FFB84D !important; }
        body.fullscreen-active #timerDisplay[style*="color: rgb(255, 69, 0)"], 
        body.fullscreen-active #timerDisplay[style*="color: #ff4500"] { color: #FF6B4D !important; }
        body.fullscreen-active #timerDisplay[style*="color: rgb(220, 53, 69)"], 
        body.fullscreen-active #timerDisplay[style*="color: #dc3545"] { color: #F87171 !important; }
        
        body.fullscreen-active #timerProgressBar[data-color-state="warning1min"] { background-color: #FFB84D !important; }
        body.fullscreen-active #timerProgressBar[data-color-state="warning30sec"] { background-color: #FF6B4D !important; }
        body.fullscreen-active #timerProgressBar[data-color-state="timesup"] { background-color: #F87171 !important; }


        body.fullscreen-active #timerStatus { 
            order: 5; 
            font-size: clamp(14px, 2.5vw, 24px); 
            color: #bbb; 
            margin-bottom: 1vh; 
        }
        body.fullscreen-active #nextSegmentPreview {
            order: 6; 
            font-size: clamp(16px, 2.8vw, 28px); 
            color: #ddd;
            border-color: #555;
            background-color: transparent; 
            margin-top: 1vh;
            margin-bottom: 1vh;
        }
        body.fullscreen-active #moderatorScript { display: none; } 
        body.fullscreen-active #speechRecognitionStatus { 
            order: 8; 
            font-size: clamp(12px, 1.6vw, 18px); 
            color: #999; 
        }
        body.fullscreen-active .timer-actions { 
            order: 9; 
            margin-top: 1.5vh; 
            margin-bottom: 1vh; 
        }
        body.fullscreen-active .debate-controls-wrapper .main-controls { 
            order: 10; 
            display: flex; 
            justify-content: center; 
            width: 100%; 
            padding-bottom: 1.5vh; 
        }
        body.fullscreen-active .debate-controls-wrapper .auto-mode-control {
            order: 11; /* Ensure it's after main controls */
            width: 100%;
            text-align: center;
            margin-top: 1vh;
            color: #ccc; /* Fullscreen color for auto mode text */
        }

        body.fullscreen-active .timer-actions button,
        body.fullscreen-active .debate-controls-wrapper .main-controls #nextStageButton { 
            display: inline-block !important; 
            padding: max(1.5vh, 10px) max(3vw, 20px); 
            font-size: clamp(14px, 2vw, 22px); 
            margin: 0 max(1vw, 6px);
            border-radius: var(--border-radius-lg); 
        }
        body.fullscreen-active .debate-controls-wrapper .main-controls #manualStartTimerButton,
        body.fullscreen-active .debate-controls-wrapper .main-controls #forceStartMainTimerButton,
        body.fullscreen-active .debate-controls-wrapper .main-controls #resetButton { display: none !important; }


        #creditFooter {
            position: fixed;
            bottom: 8px;
            right: 15px;
            font-size: 1.0em; 
            color: var(--color-text-muted);
            z-index: 999; 
            opacity: 0.7;
            transition: opacity var(--transition-fast);
        }
        #creditFooter:hover {
            opacity: 1;
        }
        #creditFooter a {
            color: inherit; 
            text-decoration: none;
        }
        #creditFooter a:hover {
            text-decoration: underline;
        }
        body.fullscreen-active #creditFooter {
             color: #aaa; 
             background-color: rgba(0,0,0,0.3); 
             padding: 2px 5px;
             border-radius: var(--border-radius-sm);
        }

        @media (max-width: 768px) {
            .container {
                padding-left: 20px;
                padding-right: 20px;
            }
            h1 { font-size: 1.8em; }
            h2 { font-size: 1.3em; }
            #timerDisplay { font-size: 2.5em; }
            #moderatorScript { font-size: 1.1em; }
            .debate-info { font-size: 0.9em; padding: 10px 15px; }
            #flowEditorList li { padding: 10px 12px; }
            #flowEditorList .editor-controls { gap: 4px; } 
             #flowEditorList .stage-info span { font-size: 0.8em; } 
        }

        @media (max-width: 480px) {
            body { padding-top: 10px; padding-bottom: 30px; } 
            .container {
                padding: 15px; 
                width: 95%; 
            }
            h1 { font-size: 1.6em; }
            h2 { font-size: 1.2em; }
            #timerDisplay { font-size: 2.2em; }
            #currentStageInfo { font-size: 1em; }
            #moderatorScript { font-size: 1em; padding: 12px; }
            .debate-info { font-size: 0.85em; padding: 8px 12px; }
            
            .debate-controls-wrapper,
            .debate-controls-wrapper .main-controls { 
                flex-direction: column; 
                align-items: stretch;
            }
             .debate-controls-wrapper .main-controls button {
                width: 100%; 
                margin: 4px 0; 
                box-sizing: border-box; 
            }
            .debate-controls-wrapper .auto-mode-control {
                text-align: center; /* Center auto mode toggle on small screens */
                margin-top: 10px;
            }

             #flowEditorList .editor-controls {
                 flex-direction: column;
                 align-items: flex-end; 
                 gap: 5px; 
                 margin-top: 8px;
             }
             #flowEditorList .editor-controls > button, 
             #flowEditorList .editor-controls .more-actions-container { 
                 width: auto; 
                 margin-left: 0; 
             }
             .editor-controls .more-actions-dropdown { 
                left: auto;
                right: 0;
             }
            
            .modal-content {
                 width: 90%; 
                 padding: 20px 15px;
            }
            .modal-content h3 { font-size: 1.3em; }
            #shortcutHelpList li strong { width: 100px; } 

            #creditFooter { font-size: 0.8em; right: 10px; bottom: 5px;}
        }

    </style>
</head>
<body>
    <button id="fullscreenButton">é€²å…¥å…¨è¢å¹•</button>

    <div class="container">
        <h1>è¾¯æ™‚è¨ˆ</h1> 
        <button id="themeToggleButton">åˆ‡æ›æ·±è‰²æ¨¡å¼</button>

        <div id="setupPhase" class="setup-section">
            <h2>è³½å‰è¨­å®š</h2>
            <div><label for="formatSelect">é¸æ“‡æ¯”è³½æµç¨‹ç¯„æœ¬ï¼š</label><select id="formatSelect"></select></div>
            <div><label for="positiveTeamNameInput">æ­£æ–¹éšŠåï¼š</label><input type="text" id="positiveTeamNameInput" value="æ­£æ–¹"></div>
            <div><label for="negativeTeamNameInput">åæ–¹éšŠåï¼š</label><input type="text" id="negativeTeamNameInput" value="åæ–¹"></div>
            <div><label for="debateTopicInput">è¾¯é¡Œï¼š</label><input type="text" id="debateTopicInput" value="ï¼ˆåœ¨æ­¤è¼¸å…¥è¾¯é¡Œï¼‰"></div>
            <div class="setup-controls" style="margin-top:15px;">
                <button id="editFlowButton">ç·¨è¼¯ç›®å‰é¸å®šæµç¨‹</button>
                <button id="confirmSetupButton">ç¢ºèªè¨­å®šï¼Œé€²è¡Œä¸‹ä¸€æ­¥</button>
            </div>
            <div class="flow-io-section" style="margin-top: 20px; padding-top:15px; border-top: 1px solid var(--color-border-light);">
                <h4>æµç¨‹åŒ¯å…¥/åŒ¯å‡º (JSON)</h4>
                <div class="flow-io"><button id="exportFlowButton">åŒ¯å‡ºæµç¨‹å®šç¾©</button></div>
                <div>
                    <label for="importFlowInput" style="margin-top:10px; text-align:center;">åŒ¯å…¥æµç¨‹æª”æ¡ˆï¼š</label>
                    <input type="file" id="importFlowInput" accept=".json" style="margin-bottom: 10px;">
                    <div id="fileImportStatus"></div>
                    <button id="loadImportedFlowButton" class="hidden">è¼‰å…¥æ­¤åŒ¯å…¥æµç¨‹</button>
                </div>
            </div>
        </div>

        <div id="flowEditorSection" class="hidden">
            <h2>æ¯”è³½æµç¨‹ç·¨è¼¯å™¨</h2>
            <p style="color: var(--color-text-muted); font-size: 0.9em;">æ‚¨å¯ä»¥æ‹–æ›³é …ç›®ä¾†æ’åºï¼Œæˆ–ä½¿ç”¨æŒ‰éˆ•ç·¨è¼¯/åˆªé™¤/ç§»å‹•éšæ®µã€‚</p>
            <ul id="flowEditorList"></ul>
            <div class="editor-controls" style="margin-top:15px;">
                <button id="addStageButton">ï¼‹ æ–°å¢éšæ®µ (æœ«å°¾)</button>
                <button id="finishEditingButton">å®Œæˆç·¨è¼¯</button>
                <button id="cancelEditingButton">å–æ¶ˆç·¨è¼¯</button>
            </div>
        </div>

        <div id="stageEditModal" class="modal">
            <div class="modal-content">
                <span class="close-button" onclick="closeModal()">&times;</span>
                <h3 id="modalTitle">ç·¨è¼¯éšæ®µ</h3>
                <input type="hidden" id="editingStageIndex">
                
                <fieldset>
                    <legend>åŸºæœ¬è³‡è¨Š</legend>
                    <div><label for="stageNameInput">éšæ®µåç¨±:</label><input type="text" id="stageNameInput"></div>
                    <div>
                        <label for="stageTypeSelect">éšæ®µé¡å‹:</label>
                        <select id="stageTypeSelect">
                            <option value="announcement">ğŸ“¢ å®£å‘Š/æç¤º</option>
                            <option value="draw_rebuttal_order">ğŸ² çµè¾¯é †åºæŠ½ç±¤</option>
                            <option value="manual_prep">â±ï¸ æ‰‹å‹•æº–å‚™è¨ˆæ™‚</option>
                            <option value="speech_auto">ğŸ¤ è‡ªå‹•ç™¼è¨€è¨ˆæ™‚</option>
                        </select>
                    </div>
                </fieldset>

                <fieldset id="timingSettingsFieldset"> 
                    <legend>è¨ˆæ™‚è¨­å®š</legend>
                    <div id="durationInputContainer" class="hidden"><label for="stageDurationInput">ä¸»è¦æŒçºŒæ™‚é–“ (ç§’):</label><input type="number" id="stageDurationInput" min="1"></div>
                    <div id="timerLabelInputContainer" class="hidden"><label for="stageTimerLabelInput">è¨ˆæ™‚å™¨æ¨™ç±¤:</label><input type="text" id="stageTimerLabelInput" placeholder="ä¾‹å¦‚ï¼šç”³è«–æ™‚é–“"></div>
                    
                    <div id="graceDurationInputContainer" class="hidden">
                        <label for="stageGraceDurationInput">ç™¼è¨€æº–å‚™ç·©è¡æ™‚é–“ (ç§’):</label>
                        <input type="number" id="stageGraceDurationInput" min="0" placeholder="é è¨­ 60">
                    </div>
                </fieldset>
                
                <fieldset id="speechAutoSettingsFieldset" class="hidden">
                    <legend>ğŸ¤ è‡ªå‹•ç™¼è¨€å°ˆå±¬è¨­å®š</legend>
                    <div id="graceEndActionContainer">
                        <label for="stageGraceEndActionSelect">ç·©è¡æ™‚é–“çµæŸå¾Œå‹•ä½œ:</label>
                        <select id="stageGraceEndActionSelect">
                            <option value="auto_start">è‡ªå‹•é–‹å§‹ä¸»è¦è¨ˆæ™‚</option>
                            <option value="manual_start">æç¤ºä¸¦ç­‰å¾…æ‰‹å‹•é–‹å§‹</option>
                            <option value="auto_skip">è‡ªå‹•è·³éæ­¤éšæ®µ</option>
                        </select>
                    </div>
                </fieldset>

                <fieldset>
                    <legend>ç¨¿ä»¶å…§å®¹</legend>
                    <div><label for="stageScriptInput">ä¸»æŒäººç¨¿ä»¶:</label><textarea id="stageScriptInput"></textarea></div>
                </fieldset>
                
                <div class="modal-buttons">
                    <button onclick="saveStageChanges()">å„²å­˜è®Šæ›´</button>
                    <button onclick="closeModal()">å–æ¶ˆ</button>
                </div>
            </div>
        </div>

        <div id="debatePhase" class="hidden">
            <div id="fullscreenRealTimeClock" class="hidden">00:00:00</div> 
            <div id="debateInfoDisplay" class="debate-info"></div>
            <div id="drawRebuttalOrderSection" class="draw-section hidden"><h3>çµè¾¯é †åºæŠ½ç±¤</h3><div id="drawResultDisplay"></div><div class="draw-controls"><button id="startDrawButton">é–‹å§‹æŠ½ç±¤</button></div></div>
            <div id="currentStageInfo"></div><div id="moderatorScript"></div>
            <div id="timerStatus"></div>
            <div id="timerDisplay" class="hidden">00:00</div>
            <div id="timerProgressBarContainer" class="hidden">
                <div id="timerProgressBar"></div>
            </div>
            <div id="nextSegmentPreview" class="hidden"></div>
            <div class="timer-actions"><button id="pauseResumeTimerButton" class="hidden pause-resume-button">æš«åœè¨ˆæ™‚</button><button id="skipStageButton" class="hidden skip-button">è·³é</button></div>
            <div id="speechRecognitionStatus" class="hidden"></div>
            
            <div class="debate-controls-wrapper controls"> <div class="main-controls"> <button id="nextStageButton" class="hidden">ä¸‹ä¸€éšæ®µ</button>
                    <button id="manualStartTimerButton" class="hidden">é–‹å§‹è¨ˆæ™‚</button>
                    <button id="forceStartMainTimerButton" class="hidden manual-override-button">æ‰‹å‹•è¨ˆæ™‚</button>
                    <button id="resetButton" class="hidden">é‡ç½®</button>
                </div>
                <div class="auto-mode-control"> <label><input type="checkbox" id="autoModeToggle"> è‡ªå‹•æ¨¡å¼</label>
                </div>
            </div>
        </div>
        <div class="info">æç¤ºï¼šå»ºè­°ä½¿ç”¨é›»è…¦ç‰ˆ Chrome / Edge ç€è¦½å™¨ã€‚è«‹ç¢ºä¿éº¥å…‹é¢¨æ¬Šé™é–‹å•Ÿã€‚æŒ‰ "/" é¡¯ç¤ºå¿«æ·éµã€‚</div>
    </div>

    <audio id="warningSound1min" src="warning_1min.ogg" preload="auto"></audio>
    <audio id="warningSound30sec" src="warning_30sec.ogg" preload="auto"></audio>
    <audio id="timesUpSound" src="times_up.ogg" preload="auto"></audio>
    <audio id="stageAdvanceSound" src="stage_advance.ogg" preload="auto"></audio>
    <audio id="speechDetectedSound" src="speech_detected.ogg" preload="auto"></audio>
    <audio id="drawSound" src="draw_sound.ogg" preload="auto"></audio>

    <div id="shortcutHelpModal" class="modal">
        <div class="modal-content">
            <span class="close-button" onclick="closeShortcutHelpModal()">&times;</span>
            <h3>éµç›¤å¿«æ·éµ</h3>
            <ul id="shortcutHelpList">
                <li><strong>N / â†’</strong> : ä¸‹ä¸€éšæ®µ</li>
                <li><strong>P / ç©ºç™½éµ</strong> : æš«åœ/ç¹¼çºŒè¨ˆæ™‚</li>
                <li><strong>S</strong> : é–‹å§‹æ‰‹å‹•è¨ˆæ™‚ / å¼·åˆ¶é–‹å§‹ç™¼è¨€è¨ˆæ™‚ / æ‰‹å‹•é–‹å§‹(ç·©è¡å¾Œ)</li>
                <li><strong>R</strong> : é‡ç½®</li>
                <li><strong>F</strong> : å…¨è¢å¹•åˆ‡æ›</li>
                <li><strong>T</strong> : ä¸»é¡Œåˆ‡æ› (æ·ºè‰²/æ·±è‰²)</li>
                <li><strong>/</strong> : é¡¯ç¤º/éš±è—æ­¤å¿«æ·éµèªªæ˜</li>
                <li><strong>Esc</strong> : é—œé–‰æ­¤å¿«æ·éµèªªæ˜ / é—œé–‰ç·¨è¼¯å½ˆçª—</li>
            </ul>
        </div>
    </div>

    <script>
        // --- DOM Elements ---
        const fullscreenButton = document.getElementById('fullscreenButton');
        const setupPhaseDiv = document.getElementById('setupPhase');
        const debatePhaseDiv = document.getElementById('debatePhase');
        const formatSelect = document.getElementById('formatSelect');
        const confirmSetupButton = document.getElementById('confirmSetupButton');
        const positiveTeamNameInput = document.getElementById('positiveTeamNameInput');
        const negativeTeamNameInput = document.getElementById('negativeTeamNameInput');
        const debateTopicInput = document.getElementById('debateTopicInput');
        const debateInfoDisplay = document.getElementById('debateInfoDisplay');
        const drawRebuttalOrderSection = document.getElementById('drawRebuttalOrderSection');
        const startDrawButton = document.getElementById('startDrawButton');
        const drawResultDisplay = document.getElementById('drawResultDisplay');
        const moderatorScriptDisplay = document.getElementById('moderatorScript');
        const timerDisplay = document.getElementById('timerDisplay');
        const timerStatusDisplay = document.getElementById('timerStatus');
        const currentStageInfoDisplay = document.getElementById('currentStageInfo');
        const speechRecognitionStatusDisplay = document.getElementById('speechRecognitionStatus');
        const nextStageButton = document.getElementById('nextStageButton');
        const manualStartTimerButton = document.getElementById('manualStartTimerButton');
        const forceStartMainTimerButton = document.getElementById('forceStartMainTimerButton');
        const resetButton = document.getElementById('resetButton');
        const pauseResumeTimerButton = document.getElementById('pauseResumeTimerButton');
        const skipStageButton = document.getElementById('skipStageButton');
        const exportFlowButton = document.getElementById('exportFlowButton');
        const importFlowInput = document.getElementById('importFlowInput');
        const loadImportedFlowButton = document.getElementById('loadImportedFlowButton');
        const fileImportStatus = document.getElementById('fileImportStatus');
        const audioElements = { warningSound1min: document.getElementById('warningSound1min'), warningSound30sec: document.getElementById('warningSound30sec'), timesUpSound: document.getElementById('timesUpSound'), stageAdvanceSound: document.getElementById('stageAdvanceSound'), speechDetectedSound: document.getElementById('speechDetectedSound'), drawSound: document.getElementById('drawSound') };
        const editFlowButton = document.getElementById('editFlowButton');
        const flowEditorSection = document.getElementById('flowEditorSection');
        const flowEditorList = document.getElementById('flowEditorList');
        const addStageButton = document.getElementById('addStageButton');
        const finishEditingButton = document.getElementById('finishEditingButton');
        const cancelEditingButton = document.getElementById('cancelEditingButton');
        const stageEditModal = document.getElementById('stageEditModal');
        const modalTitle = document.getElementById('modalTitle');
        const editingStageIndexInput = document.getElementById('editingStageIndex');
        const stageNameInput = document.getElementById('stageNameInput');
        const stageTypeSelect = document.getElementById('stageTypeSelect');
        const durationInputContainer = document.getElementById('durationInputContainer');
        const stageDurationInput = document.getElementById('stageDurationInput');
        const timerLabelInputContainer = document.getElementById('timerLabelInputContainer');
        const stageTimerLabelInput = document.getElementById('stageTimerLabelInput');
        const stageScriptInput = document.getElementById('stageScriptInput');
        const timerProgressBarContainer = document.getElementById('timerProgressBarContainer');
        const timerProgressBar = document.getElementById('timerProgressBar');
        const nextSegmentPreview = document.getElementById('nextSegmentPreview');
        const themeToggleButton = document.getElementById('themeToggleButton');
        const bodyElement = document.body;
        const shortcutHelpModal = document.getElementById('shortcutHelpModal');
        const shortcutHelpCloseButton = shortcutHelpModal.querySelector('.close-button');
        const fullscreenRealTimeClock = document.getElementById('fullscreenRealTimeClock');

        const timingSettingsFieldset = document.getElementById('timingSettingsFieldset');
        const speechAutoSettingsFieldset = document.getElementById('speechAutoSettingsFieldset');
        const graceDurationInputContainer = document.getElementById('graceDurationInputContainer');
        const stageGraceDurationInput = document.getElementById('stageGraceDurationInput');
        const graceEndActionContainer = document.getElementById('graceEndActionContainer'); 
        const stageGraceEndActionSelect = document.getElementById('stageGraceEndActionSelect');
        const autoModeToggle = document.getElementById('autoModeToggle'); // New: Auto mode toggle


        // --- State Variables ---
        let positiveTeamName = "æ­£æ–¹"; let negativeTeamName = "åæ–¹"; let debateTopic = "ï¼ˆåœ¨æ­¤è¼¸å…¥è¾¯é¡Œï¼‰"; let rebuttalOrder = null; let currentStageIndex = -1; let timerInterval; let graceTimerInterval; let timeLeft; let isTimerPaused = false; let currentTimerType = null; let synth = window.speechSynthesis; let voices = []; const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition; let recognition; let isRecognizing = false; let recognitionManuallyStopped = false; let mainSpeechTimerStartedByGrace = false; 
        const DEFAULT_GRACE_PERIOD_DURATION = 60; 
        let importedDebateStages = null; let currentFlowDefinition = []; let originalFlowBeforeEdit = null; let initialTimerDuration = 0; 
        let currentInsertBeforeIndex = null; 
        let realTimeClockInterval = null; 
        let isAutoModeEnabled = false; // New: Auto mode state

        const stageIcons = {
            announcement: 'ğŸ“¢',
            draw_rebuttal_order: 'ğŸ²',
            manual_prep: 'â±ï¸',
            speech_auto: 'ğŸ¤'
        };


        const debateFormatDefinitions = { 
            "èè‹±ç›ƒ (æ–°å¼å¥§ç‘å²¡äº”äº”å››åˆ¶)": [ 
                { name: "è³½å‰æº–å‚™", type: "announcement", duration: null, script: "æ­¡è¿ä¾†åˆ°æœ¬æ¬¡è¾¯è«–æ¯”è³½ã€‚æœ¬æ¬¡è¾¯é¡Œç‚ºï¼šã€Œ{{debate_topic}}ã€ã€‚æ­£æ–¹ä»£è¡¨éšŠæ˜¯ {{positive_team_name}}ï¼Œåæ–¹ä»£è¡¨éšŠæ˜¯ {{negative_team_name}}ã€‚æ¯”è³½æ¡æ–°å¼å¥§ç‘å²¡äº”äº”å››åˆ¶ã€‚", timerLabel: null }, 
                { name: "çµè¾¯é †åºæŠ½ç±¤", type: "draw_rebuttal_order", duration: null, script: "é¦–å…ˆï¼Œæˆ‘å€‘ä¾†é€²è¡Œçµè¾¯é †åºæŠ½ç±¤ã€‚è«‹é»æ“Šä¸‹æ–¹æŒ‰éˆ•é–‹å§‹æŠ½ç±¤ã€‚", timerLabel: null }, 
                { name: "é–‹è³½é å‚™", type: "manual_prep", duration: 60, script: "çµè¾¯é †åºæŠ½ç±¤å®Œç•¢ã€‚ä¸»å¸­å®£å¸ƒï¼Œæ¯”è³½é–‹å§‹ã€‚{{positive_team_name}}ä¸€è¾¯æº–å‚™ä¸Šå°ç”³è«–ï¼Œè¨ˆæ™‚ä¸€åˆ†é˜æº–å‚™æ™‚é–“ã€‚", timerLabel: "æ•´é«”æº–å‚™æ™‚é–“" }, 
                { name: "æ­£æ–¹ä¸€è¾¯ ç”³è«–", type: "speech_auto", duration: 300, script: "æº–å‚™æ™‚é–“çµæŸã€‚ç¾åœ¨è«‹{{positive_team_name}}ä¸€è¾¯ä¸Šè‡ºç”³è«–ï¼Œæ™‚é–“äº”åˆ†é˜ã€‚æ‚¨æœ‰ä¸€åˆ†é˜æ™‚é–“é–‹å§‹ç™¼è¨€ï¼Œå¦å‰‡å°‡è‡ªå‹•é–‹å§‹è¨ˆæ™‚ã€‚", timerLabel: "ç”³è«–æ™‚é–“", graceDuration: DEFAULT_GRACE_PERIOD_DURATION, graceEndAction: "auto_start" }, 
                { name: "åæ–¹äºŒè¾¯ è³ªè©¢ æ­£æ–¹ä¸€è¾¯", type: "speech_auto", duration: 300, script: "æ„Ÿè¬{{positive_team_name}}ä¸€è¾¯ã€‚æ¥è‘—è«‹{{negative_team_name}}äºŒè¾¯ä¸Šè‡ºè³ªè©¢{{positive_team_name}}ä¸€è¾¯ï¼Œæ™‚é–“äº”åˆ†é˜ã€‚æ‚¨æœ‰ä¸€åˆ†é˜æ™‚é–“é–‹å§‹ç™¼è¨€ã€‚", timerLabel: "è³ªè©¢æ™‚é–“", graceDuration: DEFAULT_GRACE_PERIOD_DURATION, graceEndAction: "auto_start" }, 
                { name: "åæ–¹ä¸€è¾¯ ç”³è«–", type: "speech_auto", duration: 300, script: "æ„Ÿè¬é›™æ–¹ã€‚ç¾åœ¨è«‹{{negative_team_name}}ä¸€è¾¯ä¸Šè‡ºç”³è«–ï¼Œæ™‚é–“äº”åˆ†é˜ã€‚æ‚¨æœ‰ä¸€åˆ†é˜æ™‚é–“é–‹å§‹ç™¼è¨€ã€‚", timerLabel: "ç”³è«–æ™‚é–“", graceDuration: DEFAULT_GRACE_PERIOD_DURATION, graceEndAction: "auto_start" }, 
                { name: "æ­£æ–¹ä¸‰è¾¯ è³ªè©¢ åæ–¹ä¸€è¾¯", type: "speech_auto", duration: 300, script: "æ„Ÿè¬{{negative_team_name}}ä¸€è¾¯ã€‚æ¥è‘—è«‹{{positive_team_name}}ä¸‰è¾¯ä¸Šè‡ºè³ªè©¢{{negative_team_name}}ä¸€è¾¯ï¼Œæ™‚é–“äº”åˆ†é˜ã€‚æ‚¨æœ‰ä¸€åˆ†é˜æ™‚é–“é–‹å§‹ç™¼è¨€ã€‚", timerLabel: "è³ªè©¢æ™‚é–“", graceDuration: DEFAULT_GRACE_PERIOD_DURATION, graceEndAction: "auto_start" }, 
                { name: "æ­£æ–¹äºŒè¾¯ ç”³è«–", type: "speech_auto", duration: 300, script: "æ„Ÿè¬é›™æ–¹ã€‚ç¾åœ¨è«‹{{positive_team_name}}äºŒè¾¯ä¸Šè‡ºç”³è«–ï¼Œæ™‚é–“äº”åˆ†é˜ã€‚æ‚¨æœ‰ä¸€åˆ†é˜æ™‚é–“é–‹å§‹ç™¼è¨€ã€‚", timerLabel: "ç”³è«–æ™‚é–“", graceDuration: DEFAULT_GRACE_PERIOD_DURATION, graceEndAction: "auto_start" }, 
                { name: "åæ–¹ä¸‰è¾¯ è³ªè©¢ æ­£æ–¹äºŒè¾¯", type: "speech_auto", duration: 300, script: "æ„Ÿè¬{{positive_team_name}}äºŒè¾¯ã€‚æ¥è‘—è«‹{{negative_team_name}}ä¸‰è¾¯ä¸Šè‡ºè³ªè©¢{{positive_team_name}}äºŒè¾¯ï¼Œæ™‚é–“äº”åˆ†é˜ã€‚æ‚¨æœ‰ä¸€åˆ†é˜æ™‚é–“é–‹å§‹ç™¼è¨€ã€‚", timerLabel: "è³ªè©¢æ™‚é–“", graceDuration: DEFAULT_GRACE_PERIOD_DURATION, graceEndAction: "auto_start" }, 
                { name: "åæ–¹äºŒè¾¯ ç”³è«–", type: "speech_auto", duration: 300, script: "æ„Ÿè¬é›™æ–¹ã€‚ç¾åœ¨è«‹{{negative_team_name}}äºŒè¾¯ä¸Šè‡ºç”³è«–ï¼Œæ™‚é–“äº”åˆ†é˜ã€‚æ‚¨æœ‰ä¸€åˆ†é˜æ™‚é–“é–‹å§‹ç™¼è¨€ã€‚", timerLabel: "ç”³è«–æ™‚é–“", graceDuration: DEFAULT_GRACE_PERIOD_DURATION, graceEndAction: "auto_start" }, 
                { name: "æ­£æ–¹ä¸€è¾¯ è³ªè©¢ åæ–¹äºŒè¾¯", type: "speech_auto", duration: 300, script: "æ„Ÿè¬{{negative_team_name}}äºŒè¾¯ã€‚æ¥è‘—è«‹{{positive_team_name}}ä¸€è¾¯ä¸Šè‡ºè³ªè©¢{{negative_team_name}}äºŒè¾¯ï¼Œæ™‚é–“äº”åˆ†é˜ã€‚æ‚¨æœ‰ä¸€åˆ†é˜æ™‚é–“é–‹å§‹ç™¼è¨€ã€‚", timerLabel: "è³ªè©¢æ™‚é–“", graceDuration: DEFAULT_GRACE_PERIOD_DURATION, graceEndAction: "auto_start" }, 
                { name: "æ­£æ–¹ä¸‰è¾¯ ç”³è«–", type: "speech_auto", duration: 300, script: "æ„Ÿè¬é›™æ–¹ã€‚ç¾åœ¨è«‹{{positive_team_name}}ä¸‰è¾¯ä¸Šè‡ºç”³è«–ï¼Œæ™‚é–“äº”åˆ†é˜ã€‚æ‚¨æœ‰ä¸€åˆ†é˜æ™‚é–“é–‹å§‹ç™¼è¨€ã€‚", timerLabel: "ç”³è«–æ™‚é–“", graceDuration: DEFAULT_GRACE_PERIOD_DURATION, graceEndAction: "auto_start" }, 
                { name: "åæ–¹ä¸€è¾¯ è³ªè©¢ æ­£æ–¹ä¸‰è¾¯", type: "speech_auto", duration: 300, script: "æ„Ÿè¬{{positive_team_name}}ä¸‰è¾¯ã€‚æ¥è‘—è«‹{{negative_team_name}}ä¸€è¾¯ä¸Šè‡ºè³ªè©¢{{positive_team_name}}ä¸‰è¾¯ï¼Œæ™‚é–“äº”åˆ†é˜ã€‚æ‚¨æœ‰ä¸€åˆ†é˜æ™‚é–“é–‹å§‹ç™¼è¨€ã€‚", timerLabel: "è³ªè©¢æ™‚é–“", graceDuration: DEFAULT_GRACE_PERIOD_DURATION, graceEndAction: "auto_start" }, 
                { name: "åæ–¹ä¸‰è¾¯ ç”³è«–", type: "speech_auto", duration: 300, script: "æ„Ÿè¬é›™æ–¹ã€‚ç¾åœ¨è«‹{{negative_team_name}}ä¸‰è¾¯ä¸Šè‡ºç”³è«–ï¼Œæ™‚é–“äº”åˆ†é˜ã€‚æ‚¨æœ‰ä¸€åˆ†é˜æ™‚é–“é–‹å§‹ç™¼è¨€ã€‚", timerLabel: "ç”³è«–æ™‚é–“", graceDuration: DEFAULT_GRACE_PERIOD_DURATION, graceEndAction: "auto_start" }, 
                { name: "æ­£æ–¹äºŒè¾¯ è³ªè©¢ åæ–¹ä¸‰è¾¯", type: "speech_auto", duration: 300, script: "æ„Ÿè¬{{negative_team_name}}ä¸‰è¾¯ã€‚æ¥è‘—è«‹{{positive_team_name}}äºŒè¾¯ä¸Šè‡ºè³ªè©¢{{negative_team_name}}ä¸‰è¾¯ï¼Œæ™‚é–“äº”åˆ†é˜ã€‚æ‚¨æœ‰ä¸€åˆ†é˜æ™‚é–“é–‹å§‹ç™¼è¨€ã€‚", timerLabel: "è³ªè©¢æ™‚é–“", graceDuration: DEFAULT_GRACE_PERIOD_DURATION, graceEndAction: "auto_start" }, 
                { name: "çµè¾¯æº–å‚™", type: "manual_prep", duration: 180, script: "ç”³è«–è³ªè©¢éšæ®µå®Œç•¢ã€‚å…ˆå‰æŠ½ç±¤çµæœç‚º {{first_rebuttal_team_name}} å…ˆçµè¾¯ã€‚é›™æ–¹å°‡æœ‰ä¸‰åˆ†é˜æº–å‚™çµè¾¯ã€‚è¨ˆæ™‚é–‹å§‹ã€‚", timerLabel: "çµè¾¯æº–å‚™æ™‚é–“" }, 
                { name: "å…ˆçµè¾¯æ–¹ çµè¾¯", type: "speech_auto", duration: 240, script: "æº–å‚™æ™‚é–“åˆ°ã€‚ç¾åœ¨è«‹ {{first_rebuttal_team_name}} ä»£è¡¨ä¸Šè‡ºçµè¾¯ï¼Œæ™‚é–“å››åˆ†é˜ã€‚æ‚¨æœ‰ä¸€åˆ†é˜æ™‚é–“é–‹å§‹ç™¼è¨€ã€‚", timerLabel: "çµè¾¯æ™‚é–“", graceDuration: DEFAULT_GRACE_PERIOD_DURATION, graceEndAction: "auto_start" }, 
                { name: "å¾Œçµè¾¯æ–¹ çµè¾¯", type: "speech_auto", duration: 240, script: "æ„Ÿè¬ {{first_rebuttal_team_name}} ä»£è¡¨ã€‚ç¾åœ¨è«‹ {{second_rebuttal_team_name}} ä»£è¡¨ä¸Šè‡ºçµè¾¯ï¼Œæ™‚é–“å››åˆ†é˜ã€‚æ‚¨æœ‰ä¸€åˆ†é˜æ™‚é–“é–‹å§‹ç™¼è¨€ã€‚", timerLabel: "çµè¾¯æ™‚é–“", graceDuration: DEFAULT_GRACE_PERIOD_DURATION, graceEndAction: "auto_start" }, 
                { name: "æ¯”è³½çµæŸå®£å‘Š", type: "announcement", duration: null, script: "æ„Ÿè¬é›™æ–¹çµè¾¯ã€‚æœ¬å ´æ¯”è³½æ‰€æœ‰è³½ç¨‹åˆ°æ­¤çµæŸã€‚æ„Ÿè¬ {{positive_team_name}} èˆ‡ {{negative_team_name}} å„ä½è¾¯å£«çš„ç²¾å½©è¡¨ç¾ã€‚", timerLabel: null }, 
                { name: "æŠ—è­°æå‡ºæ™‚é–“", type: "manual_prep", duration: 600, script: "è‹¥æœ‰æŠ—è­°äº‹é …ï¼Œè«‹æ–¼ååˆ†é˜å…§ä»¥æ›¸é¢æ–¹å¼å‘ä¸»å¸­æå‡ºã€‚è¨ˆæ™‚é–‹å§‹ã€‚", timerLabel: "æŠ—è­°æå‡ºæ™‚é–“" }, 
                { name: "æ­£å¼çµæŸ", type: "announcement", duration: null, script: "æŠ—è­°æå‡ºæ™‚é–“çµæŸã€‚æ„Ÿè¬å„ä½çš„åƒèˆ‡ã€‚", timerLabel: null } 
            ], 
            "ç°¡æ˜“ä¸‰å°ä¸‰å¥§ç‘å²¡ (3-3-2åˆ¶ ç¤ºä¾‹)": [ 
                { name: "è³½å‰æº–å‚™", type: "announcement", duration: null, script: "ç°¡æ˜“ä¸‰å°ä¸‰å¥§ç‘å²¡é–‹å§‹ã€‚è¾¯é¡Œï¼š{{debate_topic}}ã€‚æ­£æ–¹ï¼š{{positive_team_name}}ï¼Œåæ–¹ï¼š{{negative_team_name}}ã€‚", timerLabel: null }, 
                { name: "çµè¾¯é †åºæŠ½ç±¤", type: "draw_rebuttal_order", duration: null, script: "é€²è¡Œçµè¾¯é †åºæŠ½ç±¤ã€‚", timerLabel: null }, 
                { name: "é–‹è³½é å‚™", type: "manual_prep", duration: 30, script: "æŠ½ç±¤å®Œç•¢ã€‚{{positive_team_name}}ä¸€è¾¯æº–å‚™ï¼Œè¨ˆæ™‚30ç§’ã€‚", timerLabel: "æº–å‚™" }, 
                { name: "æ­£ä¸€ç”³è«–", type: "speech_auto", duration: 180, script: "è«‹{{positive_team_name}}ä¸€è¾¯ç”³è«–ï¼Œ3åˆ†é˜ã€‚", timerLabel: "ç”³è«–", graceDuration: DEFAULT_GRACE_PERIOD_DURATION, graceEndAction: "auto_start" }, 
                { name: "åäºŒè³ªè©¢æ­£ä¸€", type: "speech_auto", duration: 180, script: "è«‹{{negative_team_name}}äºŒè¾¯è³ªè©¢{{positive_team_name}}ä¸€è¾¯ï¼Œ3åˆ†é˜ã€‚", timerLabel: "è³ªè©¢", graceDuration: DEFAULT_GRACE_PERIOD_DURATION, graceEndAction: "auto_start" }, 
                { name: "åä¸€ç”³è«–", type: "speech_auto", duration: 180, script: "è«‹{{negative_team_name}}ä¸€è¾¯ç”³è«–ï¼Œ3åˆ†é˜ã€‚", timerLabel: "ç”³è«–", graceDuration: DEFAULT_GRACE_PERIOD_DURATION, graceEndAction: "auto_start" }, 
                { name: "æ­£äºŒè³ªè©¢åä¸€", type: "speech_auto", duration: 180, script: "è«‹{{positive_team_name}}äºŒè¾¯è³ªè©¢{{negative_team_name}}ä¸€è¾¯ï¼Œ3åˆ†é˜ã€‚", timerLabel: "è³ªè©¢", graceDuration: DEFAULT_GRACE_PERIOD_DURATION, graceEndAction: "auto_start" }, 
                { name: "æ­£ä¸‰ç”³è«–", type: "speech_auto", duration: 180, script: "è«‹{{positive_team_name}}ä¸‰è¾¯ç”³è«–ï¼Œ3åˆ†é˜ã€‚", timerLabel: "ç”³è«–", graceDuration: DEFAULT_GRACE_PERIOD_DURATION, graceEndAction: "auto_start" }, 
                { name: "åä¸€è³ªè©¢æ­£ä¸‰", type: "speech_auto", duration: 180, script: "è«‹{{negative_team_name}}ä¸€è¾¯è³ªè©¢{{positive_team_name}}ä¸‰è¾¯ï¼Œ3åˆ†é˜ã€‚", timerLabel: "è³ªè©¢", graceDuration: DEFAULT_GRACE_PERIOD_DURATION, graceEndAction: "auto_start" }, 
                { name: "åä¸‰ç”³è«–", type: "speech_auto", duration: 180, script: "è«‹{{negative_team_name}}ä¸‰è¾¯ç”³è«–ï¼Œ3åˆ†é˜ã€‚", timerLabel: "ç”³è«–", graceDuration: DEFAULT_GRACE_PERIOD_DURATION, graceEndAction: "auto_start" }, 
                { name: "æ­£ä¸€è³ªè©¢åä¸‰", type: "speech_auto", duration: 180, script: "è«‹{{positive_team_name}}ä¸€è¾¯è³ªè©¢{{negative_team_name}}ä¸‰è¾¯ï¼Œ3åˆ†é˜ã€‚", timerLabel: "è³ªè©¢", graceDuration: DEFAULT_GRACE_PERIOD_DURATION, graceEndAction: "auto_start" }, 
                { name: "çµè¾¯æº–å‚™", type: "manual_prep", duration: 60, script: "ç”³è«–è³ªè©¢å®Œç•¢ã€‚å…ˆå‰æŠ½ç±¤ç‚º {{first_rebuttal_team_name}} å…ˆçµè¾¯ã€‚æº–å‚™çµè¾¯ï¼Œ1åˆ†é˜ã€‚", timerLabel: "çµè¾¯æº–å‚™" }, 
                { name: "å…ˆçµè¾¯æ–¹çµè¾¯", type: "speech_auto", duration: 120, script: "è«‹ {{first_rebuttal_team_name}} çµè¾¯ï¼Œ2åˆ†é˜ã€‚", timerLabel: "çµè¾¯", graceDuration: DEFAULT_GRACE_PERIOD_DURATION, graceEndAction: "auto_start" }, 
                { name: "å¾Œçµè¾¯æ–¹çµè¾¯", type: "speech_auto", duration: 120, script: "è«‹ {{second_rebuttal_team_name}} çµè¾¯ï¼Œ2åˆ†é˜ã€‚", timerLabel: "çµè¾¯", graceDuration: DEFAULT_GRACE_PERIOD_DURATION, graceEndAction: "auto_start" }, 
                { name: "æ¯”è³½çµæŸ", type: "announcement", duration: null, script: "æ¯”è³½çµæŸã€‚æ„Ÿè¬å„ä½ã€‚", timerLabel: null } 
            ] 
        };
        
        function playSound(soundName) { const audio = audioElements[soundName]; if (audio) { audio.currentTime = 0; audio.play().catch(error => console.warn(`Error playing sound "${soundName}":`, error.message)); } }
        function populateVoiceList() { voices = synth.getVoices().filter(voice => voice.lang.startsWith('zh')); if (voices.length === 0) voices = synth.getVoices(); }
        populateVoiceList();
        if (speechSynthesis.onvoiceschanged !== undefined) speechSynthesis.onvoiceschanged = populateVoiceList;
        function speak(text, callback) { if (synth.speaking) synth.cancel(); const u = new SpeechSynthesisUtterance(text); u.onend = () => { if (callback) callback(); }; u.onerror = (event) => { console.warn('SpeechSynErr:', event.error); if (callback) callback(); }; let v = voices.find(vo => vo.lang === 'zh-TW' || vo.lang === 'zh-CN') || voices.find(vo => vo.lang.startsWith('zh')); if(v) u.voice = v; else if(voices.length > 0) u.voice = voices[0]; synth.speak(u); }
        function interpolateScript(script) { let firstTeam = "", secondTeam = ""; if(rebuttalOrder){ firstTeam = rebuttalOrder === 'positive_first' ? positiveTeamName : negativeTeamName; secondTeam = rebuttalOrder === 'positive_first' ? negativeTeamName : positiveTeamName; } return script.replace(/\{\{positive_team_name\}\}/g, positiveTeamName).replace(/\{\{negative_team_name\}\}/g, negativeTeamName).replace(/\{\{debate_topic\}\}/g, debateTopic).replace(/\{\{first_rebuttal_team_name\}\}/g, firstTeam).replace(/\{\{second_rebuttal_team_name\}\}/g, secondTeam); }
        function formatTime(seconds) { const m = Math.floor(seconds / 60); const s = seconds % 60; return `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`; }
        function updateTimerDisplayDOM(currentTime) { timerDisplay.textContent = formatTime(currentTime); }
        
        function updateProgressBar(currentTime, totalDuration) {
            if (totalDuration <= 0) {
                timerProgressBar.style.width = '0%';
                return;
            }
            const percentageElapsed = ((totalDuration - currentTime) / totalDuration) * 100;
            timerProgressBar.style.width = `${Math.min(100, Math.max(0, percentageElapsed))}%`;

            const isFullscreen = document.body.classList.contains('fullscreen-active');
            let progressBarColorState = ""; 

            let colorWarning = getComputedStyle(document.documentElement).getPropertyValue('--color-warning').trim();
            let colorOrangeAccent = getComputedStyle(document.documentElement).getPropertyValue('--color-orange-accent').trim();
            let colorDanger = getComputedStyle(document.documentElement).getPropertyValue('--color-danger').trim();
            let colorPrimary = getComputedStyle(document.documentElement).getPropertyValue('--color-primary').trim();

            if (isFullscreen) {
                colorWarning = '#FFB84D';
                colorOrangeAccent = '#FF6B4D';
                colorDanger = '#F87171';
                colorPrimary = '#259DFA';
            }
            

            if (currentTime <= 0) {
                timerProgressBar.style.backgroundColor = colorDanger;
                 progressBarColorState = "timesup";
            } else if (currentTime <= 30 && totalDuration > 30) {
                timerProgressBar.style.backgroundColor = colorOrangeAccent;
                progressBarColorState = "warning30sec";
            } else if (currentTime <= 60 && totalDuration > 60) {
                timerProgressBar.style.backgroundColor = colorWarning;
                 progressBarColorState = "warning1min";
            } else {
                timerProgressBar.style.backgroundColor = colorPrimary;
                 progressBarColorState = "";
            }
            if (isFullscreen) {
                timerProgressBar.dataset.colorState = progressBarColorState;
            } else {
                 timerProgressBar.removeAttribute('data-color-state');
            }
        }

        function startRecognitionConditionally() { if (SpeechRecognition && recognition && !isRecognizing && currentTimerType === 'grace' && !isTimerPaused) { recognitionManuallyStopped = false; try { recognition.start(); } catch(e) { console.error("SR start err:", e); speechRecognitionStatusDisplay.textContent = "å•Ÿå‹•è­˜åˆ¥å¤±æ•—ã€‚";}} }
        function stopRecognitionForce() { recognitionManuallyStopped = true; if (SpeechRecognition && recognition && isRecognizing) { try { recognition.stop(); } catch (e) { if (e.name !== 'InvalidStateError'){console.error("SR stop err:", e);}}} isRecognizing = false; }
        if (SpeechRecognition) {
            recognition = new SpeechRecognition(); recognition.continuous = true; recognition.interimResults = false; recognition.lang = 'zh-TW';
            recognition.onstart = () => { isRecognizing = true; recognitionManuallyStopped = false; speechRecognitionStatusDisplay.textContent = "èªéŸ³è­˜åˆ¥å·²å•Ÿå‹•...";};
            recognition.onresult = (event) => { if (currentTimerType === 'grace' && graceTimerInterval && !mainSpeechTimerStartedByGrace && !isTimerPaused) { clearTimeout(graceTimerInterval); graceTimerInterval = null; forceStartMainTimerButton.classList.add('hidden'); skipStageButton.classList.add('hidden'); timerStatusDisplay.textContent = "åµæ¸¬åˆ°ç™¼è¨€..."; speak("åµæ¸¬åˆ°ç™¼è¨€ï¼Œè¨ˆæ™‚é–‹å§‹ã€‚", () => startMainSpeechTimer(currentFlowDefinition[currentStageIndex].duration)); playSound('speechDetectedSound'); mainSpeechTimerStartedByGrace = true;}};
            recognition.onerror = (event) => {isRecognizing = false; console.warn("SR.onerror:", event.error, event.message); let msg=`SR Err: ${event.error}`; let restart = false; if(event.error==='no-speech'){msg="æœªåµæ¸¬åˆ°èªéŸ³ã€‚"; restart=true;} else if(event.error==='audio-capture')msg="éº¥å…‹é¢¨éŒ¯èª¤ã€‚"; else if(event.error==='not-allowed'){msg="éº¥å…‹é¢¨æ¬Šé™æœªæˆäºˆã€‚"; alert(msg); if(currentFlowDefinition[currentStageIndex] && currentFlowDefinition[currentStageIndex].type === 'speech_auto' && currentTimerType === 'grace')forceStartMainTimerButton.classList.remove('hidden');} else if(event.error === 'aborted'){msg="èªéŸ³è­˜åˆ¥è¢«ä¸­æ­¢ã€‚";} else if (event.error === 'network' || event.error === 'service-not-allowed'){msg=`æœå‹™éŒ¯èª¤(${event.error})ã€‚`; restart=true;} if(event.error !== 'aborted')speechRecognitionStatusDisplay.textContent=msg; if (currentTimerType === 'grace' && !isTimerPaused && graceTimerInterval && restart && !recognitionManuallyStopped){console.log(`SR err (${event.error}), restarting...`); setTimeout(startRecognitionConditionally, 250);}};
            recognition.onend = () => { const wasRec = isRecognizing; isRecognizing = false; if (currentTimerType === 'grace' && !isTimerPaused && graceTimerInterval && !recognitionManuallyStopped && wasRec){console.log("SR ended early, restarting..."); setTimeout(startRecognitionConditionally, 250);} else {const cs=speechRecognitionStatusDisplay.textContent; if(!cs.includes("éŒ¯èª¤")&&!cs.includes("æœªæˆäºˆ")&&cs!=="èªéŸ³è­˜åˆ¥å·²å•Ÿå‹•..." && (!cs.includes("ä¸­æ­¢") || !recognitionManuallyStopped) ){}}};
        } else { speechRecognitionStatusDisplay.textContent = "ç€è¦½å™¨ä¸æ”¯æ´èªéŸ³è­˜åˆ¥ã€‚"; }

        function clearAllTimersAndIntervals() { clearInterval(timerInterval); clearInterval(graceTimerInterval); timerInterval = null; graceTimerInterval = null; isTimerPaused = false; currentTimerType = null; pauseResumeTimerButton.textContent = "æš«åœè¨ˆæ™‚"; pauseResumeTimerButton.classList.add('hidden'); skipStageButton.classList.add('hidden'); forceStartMainTimerButton.classList.add('hidden'); timerProgressBar.style.width = '0%'; timerProgressBarContainer.classList.add('hidden');}
        
        function runActiveTimerInterval() { 
            if (isTimerPaused) return; 
            timeLeft--; 
            updateTimerDisplayDOM(timeLeft); 
            if (currentTimerType === 'main' || currentTimerType === 'manual_prep' || currentTimerType === 'grace') {
                 updateProgressBar(timeLeft, initialTimerDuration); 
            }
            
            const isFullscreen = document.body.classList.contains('fullscreen-active');
            let defaultTimerColor = getComputedStyle(timerDisplay).color; 
            let warning1MinColor = isFullscreen ? '#FFB84D' : getComputedStyle(document.documentElement).getPropertyValue('--color-warning').trim();
            let warning30SecColor = isFullscreen ? '#FF6B4D' : getComputedStyle(document.documentElement).getPropertyValue('--color-orange-accent').trim(); 
            let timesUpColor = isFullscreen ? '#F87171' : getComputedStyle(document.documentElement).getPropertyValue('--color-danger').trim();

            if (isFullscreen) {
                defaultTimerColor = '#259DFA'; 
            }


            if (currentTimerType === 'grace') { 
                 if (timeLeft <= 0) { 
                    clearTimeout(graceTimerInterval); 
                    graceTimerInterval = null; 
                    stopRecognitionForce(); 
                    forceStartMainTimerButton.classList.add('hidden'); 
                    if (!mainSpeechTimerStartedByGrace) {
                        const currentStage = currentFlowDefinition[currentStageIndex];
                        const graceEndAction = currentStage.graceEndAction || 'auto_start';

                        switch(graceEndAction) {
                            case 'auto_start':
                                timerStatusDisplay.textContent = "ç™¼è¨€æº–å‚™æ™‚é–“å·²åˆ°..."; 
                                speak("æº–å‚™æ™‚é–“åˆ°ï¼Œè¨ˆæ™‚é–‹å§‹ã€‚", () => { 
                                    startMainSpeechTimer(currentStage.duration); 
                                    pauseResumeTimerButton.classList.remove('hidden'); 
                                    pauseResumeTimerButton.textContent = "æš«åœè¨ˆæ™‚"; 
                                    skipStageButton.classList.add('hidden'); 
                                }); 
                                mainSpeechTimerStartedByGrace = true;
                                break;
                            case 'manual_start':
                                timerStatusDisplay.textContent = "æº–å‚™æ™‚é–“å·²åˆ°ï¼Œè«‹æ‰‹å‹•é–‹å§‹è¨ˆæ™‚ã€‚";
                                speak("æº–å‚™æ™‚é–“åˆ°ï¼Œè«‹æ‰‹å‹•é–‹å§‹è¨ˆæ™‚ã€‚");
                                forceStartMainTimerButton.classList.remove('hidden'); 
                                forceStartMainTimerButton.textContent = "é–‹å§‹ä¸»è¦è¨ˆæ™‚"; 
                                nextStageButton.disabled = true; 
                                pauseResumeTimerButton.classList.add('hidden');
                                break;
                            case 'auto_skip':
                                timerStatusDisplay.textContent = "æº–å‚™æ™‚é–“å·²åˆ°ï¼Œè‡ªå‹•è·³éæ­¤éšæ®µã€‚";
                                speak("æº–å‚™æ™‚é–“åˆ°ï¼Œè‡ªå‹•è·³éæ­¤éšæ®µã€‚", () => {
                                    if(isAutoModeEnabled || currentStage.graceEndAction === 'auto_skip') { // Check if still relevant
                                        loadNextStage();
                                    }
                                });
                                break;
                        }
                    }
                }
            } else if (currentTimerType === 'main' || currentTimerType === 'manual_prep') { 
                const d = initialTimerDuration; 
                const endedStageIndex = currentStageIndex; // Capture current stage index before it potentially changes

                if (timeLeft === 60 && d > 60) { 
                    speak("æ™‚é–“å‰©é¤˜ä¸€åˆ†é˜"); 
                    timerDisplay.style.color = warning1MinColor; 
                    playSound('warningSound1min'); 
                } else if (timeLeft === 30 && d > 30) { 
                    speak("æ™‚é–“å‰©é¤˜ä¸‰åç§’"); 
                    timerDisplay.style.color = warning30SecColor;
                    playSound('warningSound30sec'); 
                } else if (timeLeft <= 0) { 
                    clearInterval(timerInterval); 
                    timerInterval = null; 
                    speak("æ™‚é–“åˆ°"); 
                    timerDisplay.textContent = "æ™‚é–“åˆ°"; 
                    timerDisplay.style.color = timesUpColor; 
                    playSound('timesUpSound'); 
                    currentTimerType = null; 

                    if (endedStageIndex >= currentFlowDefinition.length - 1) { 
                        nextStageButton.disabled = true;
                    } else {
                        const wouldOriginalAutoAdvance = currentFlowDefinition[endedStageIndex]?.type === "manual_prep" && endedStageIndex < currentFlowDefinition.length - 2;
                        if (isAutoModeEnabled) {
                            timerStatusDisplay.textContent = "æ™‚é–“åˆ°ï¼Œæº–å‚™é€²å…¥ä¸‹ä¸€éšæ®µ...";
                            setTimeout(() => {
                                if (currentStageIndex === endedStageIndex && !isTimerPaused && !timerInterval && !graceTimerInterval) {
                                     loadNextStage();
                                }
                            }, 2000); 
                        } else {
                            if (wouldOriginalAutoAdvance) {
                                 loadNextStage(); 
                            } else {
                                 nextStageButton.disabled = false; 
                            }
                        }
                    }
                } else if (timeLeft > 60 || (timeLeft > 30 && d <=60) || (d <= 30)) { 
                    timerDisplay.style.color = defaultTimerColor;
                }
            }
        }
        function startGracePeriodTimer() { 
            clearAllTimersAndIntervals(); 
            currentTimerType = 'grace'; 
            mainSpeechTimerStartedByGrace = false; 
            
            const currentStage = currentFlowDefinition[currentStageIndex];
            const graceDuration = (typeof currentStage.graceDuration === 'number' && currentStage.graceDuration >= 0) 
                                ? currentStage.graceDuration 
                                : DEFAULT_GRACE_PERIOD_DURATION;

            timeLeft = graceDuration; 
            initialTimerDuration = graceDuration; 

            timerStatusDisplay.textContent = `è«‹æ–¼${formatTime(graceDuration)}å…§é–‹å§‹ç™¼è¨€...`; 
            updateTimerDisplayDOM(timeLeft); 
            timerDisplay.classList.remove('hidden'); 
            timerProgressBarContainer.classList.remove('hidden'); 
            updateProgressBar(timeLeft, initialTimerDuration); 
            
            const isFullscreen = document.body.classList.contains('fullscreen-active');
            timerDisplay.style.color = isFullscreen ? '#259DFA' : getComputedStyle(document.documentElement).getPropertyValue('--color-primary').trim();


            speechRecognitionStatusDisplay.classList.remove('hidden'); 
            
            const graceEndAction = currentStage.graceEndAction || 'auto_start';
            if (graceEndAction !== 'auto_skip') { 
                forceStartMainTimerButton.classList.remove('hidden');
                forceStartMainTimerButton.textContent = "å¼·åˆ¶é–‹å§‹ç™¼è¨€è¨ˆæ™‚"; 
            } else {
                 forceStartMainTimerButton.classList.add('hidden');
            }

            pauseResumeTimerButton.textContent = "æš«åœè¨ˆæ™‚"; 
            pauseResumeTimerButton.classList.remove('hidden'); 
            skipStageButton.classList.add('hidden'); 
            startRecognitionConditionally(); 
            graceTimerInterval = setInterval(runActiveTimerInterval, 1000); 
        }
        function startMainSpeechTimer(duration) { 
            stopRecognitionForce(); 
            if (currentTimerType !== 'grace') { 
                clearAllTimersAndIntervals();
            }
            currentTimerType = 'main'; 
            timeLeft = duration; 
            initialTimerDuration = duration; 
            timerStatusDisplay.textContent = (currentFlowDefinition[currentStageIndex]?.timerLabel || "è¨ˆæ™‚") + "é€²è¡Œä¸­..."; 
            updateTimerDisplayDOM(timeLeft); 
            timerDisplay.classList.remove('hidden'); 
            timerProgressBarContainer.classList.remove('hidden'); 
            updateProgressBar(timeLeft, initialTimerDuration); 
            
            const isFullscreen = document.body.classList.contains('fullscreen-active');
            timerDisplay.style.color = isFullscreen ? '#259DFA' : getComputedStyle(document.documentElement).getPropertyValue('--color-primary').trim();

            nextStageButton.disabled = true; 
            pauseResumeTimerButton.textContent = "æš«åœè¨ˆæ™‚"; 
            pauseResumeTimerButton.classList.remove('hidden'); 
            skipStageButton.classList.add('hidden'); 
            forceStartMainTimerButton.classList.add('hidden'); 
            if (timerInterval) clearInterval(timerInterval); 
            if (graceTimerInterval) { clearInterval(graceTimerInterval); graceTimerInterval = null; } 
            timerInterval = setInterval(runActiveTimerInterval, 1000); 
        }
        function startManualPrepTimer(duration) { 
            stopRecognitionForce(); 
            clearAllTimersAndIntervals(); 
            currentTimerType = 'manual_prep'; 
            timeLeft = duration; 
            initialTimerDuration = duration; 
            timerStatusDisplay.textContent = (currentFlowDefinition[currentStageIndex]?.timerLabel || "æº–å‚™è¨ˆæ™‚") + "é€²è¡Œä¸­..."; 
            updateTimerDisplayDOM(timeLeft); 
            timerDisplay.classList.remove('hidden'); 
            timerProgressBarContainer.classList.remove('hidden'); 
            updateProgressBar(timeLeft, initialTimerDuration); 
            
            const isFullscreen = document.body.classList.contains('fullscreen-active');
            timerDisplay.style.color = isFullscreen ? '#259DFA' : getComputedStyle(document.documentElement).getPropertyValue('--color-primary').trim();

            nextStageButton.disabled = true; 
            manualStartTimerButton.disabled = true; 
            pauseResumeTimerButton.textContent = "æš«åœè¨ˆæ™‚"; 
            pauseResumeTimerButton.classList.remove('hidden'); 
            skipStageButton.classList.add('hidden'); 
            timerInterval = setInterval(runActiveTimerInterval, 1000); 
        }

        pauseResumeTimerButton.addEventListener('click', () => { 
            isTimerPaused = !isTimerPaused; 
            if (isTimerPaused) { 
                recognitionManuallyStopped = true; 
                if(currentTimerType === 'grace' && graceTimerInterval) { 
                    clearInterval(graceTimerInterval); 
                    stopRecognitionForce(); 
                } else if ((currentTimerType === 'main' || currentTimerType === 'manual_prep') && timerInterval) { 
                    clearInterval(timerInterval); 
                } 
                pauseResumeTimerButton.textContent = "ç¹¼çºŒè¨ˆæ™‚"; 
                timerStatusDisplay.textContent += " (å·²æš«åœ)"; 
                skipStageButton.classList.remove('hidden'); 
                nextStageButton.disabled = true; 
            } else { 
                pauseResumeTimerButton.textContent = "æš«åœè¨ˆæ™‚"; 
                timerStatusDisplay.textContent = timerStatusDisplay.textContent.replace(" (å·²æš«åœ)", ""); 
                skipStageButton.classList.add('hidden'); 
                if (currentTimerType === 'grace') { 
                    startRecognitionConditionally(); 
                    graceTimerInterval = setInterval(runActiveTimerInterval, 1000); 
                } else if (currentTimerType === 'main' || currentTimerType === 'manual_prep') { 
                    timerInterval = setInterval(runActiveTimerInterval, 1000);
                }
            }
        });
        skipStageButton.addEventListener('click', () => { if (isTimerPaused) { stopRecognitionForce(); clearAllTimersAndIntervals(); loadNextStage(); }});

        let sortableInstance = null;

        function toggleMoreActionsDropdown(event) {
            event.stopPropagation(); 
            const dropdown = event.currentTarget.nextElementSibling;
            const isActive = dropdown.classList.contains('active');
            document.querySelectorAll('#flowEditorList .more-actions-dropdown.active').forEach(openDropdown => {
                openDropdown.classList.remove('active');
            });
            if (!isActive) { 
                dropdown.classList.add('active');
            }
        }
        
        function renderEditorList() { 
            flowEditorList.innerHTML = ''; 
            currentFlowDefinition.forEach((stage, index) => { 
                const li = document.createElement('li'); 
                li.dataset.index = index; 
                
                const infoOuterDiv = document.createElement('div'); 
                infoOuterDiv.classList.add('stage-info');

                const stageIconSpan = document.createElement('span');
                stageIconSpan.classList.add('stage-icon');
                stageIconSpan.textContent = stageIcons[stage.type] || 'âš™ï¸';
                infoOuterDiv.appendChild(stageIconSpan);

                const infoTextDiv = document.createElement('div'); 

                const nameStrong = document.createElement('strong');
                nameStrong.textContent = `${index + 1}. ${stage.name || '(æœªå‘½å)'}`;
                infoTextDiv.appendChild(nameStrong);

                const detailsSpan = document.createElement('span');
                let detailsText = `é¡å‹: ${stage.type || '(æœªçŸ¥)'}`;
                if (stage.duration) detailsText += `, æ™‚é–“: ${stage.duration}s`;
                if (stage.type === 'speech_auto' && typeof stage.graceDuration === 'number') {
                    detailsText += `, ç·©è¡: ${stage.graceDuration}s`;
                }
                detailsSpan.textContent = detailsText;
                infoTextDiv.appendChild(detailsSpan);
                
                const scriptSpan = document.createElement('span');
                scriptSpan.style.whiteSpace = 'nowrap';
                scriptSpan.style.overflow = 'hidden';
                scriptSpan.style.textOverflow = 'ellipsis';
                scriptSpan.style.maxWidth = '300px'; 
                scriptSpan.textContent = `ç¨¿ä»¶: ${stage.script ? stage.script.substring(0, 50) + (stage.script.length > 50 ? '...' : '') : '(ç„¡)'}`;
                infoTextDiv.appendChild(scriptSpan);
                
                infoOuterDiv.appendChild(infoTextDiv);

                const controlsDiv = document.createElement('div'); 
                controlsDiv.classList.add('editor-controls');

                const editButton = document.createElement('button');
                editButton.classList.add('edit');
                editButton.title = 'ç·¨è¼¯æ­¤éšæ®µ';
                editButton.innerHTML = 'ç·¨è¼¯'; 
                editButton.onclick = () => openEditModal(index);
                controlsDiv.appendChild(editButton);

                const deleteButton = document.createElement('button');
                deleteButton.classList.add('delete');
                deleteButton.title = 'åˆªé™¤æ­¤éšæ®µ';
                deleteButton.innerHTML = 'åˆªé™¤'; 
                deleteButton.onclick = () => deleteStage(index);
                controlsDiv.appendChild(deleteButton);

                const moreActionsContainer = document.createElement('div');
                moreActionsContainer.classList.add('more-actions-container');

                const moreButton = document.createElement('button');
                moreButton.classList.add('more-actions-btn');
                moreButton.innerHTML = '...';
                moreButton.title = 'æ›´å¤šæ“ä½œ';
                moreButton.onclick = toggleMoreActionsDropdown;
                moreActionsContainer.appendChild(moreButton);

                const dropdownDiv = document.createElement('div');
                dropdownDiv.classList.add('more-actions-dropdown');
                
                dropdownDiv.innerHTML = 
                    `<button class="insert-before" onclick="openEditModal(-1, ${index})" title="åœ¨æ­¤éšæ®µä¹‹å‰æ’å…¥æ–°éšæ®µ">ï¼‹ å‰æ–¹æ’å…¥</button>` + 
                    `<button class="duplicate" onclick="duplicateStage(${index})" title="è¤‡è£½æ­¤éšæ®µ">è¤‡è£½</button>` + 
                    `<button class="move move-up" onclick="moveStage(${index}, -1)" ${index === 0 ? 'disabled' : ''} title="ä¸Šç§»æ­¤éšæ®µ">â†‘ ä¸Šç§»</button>` +
                    `<button class="move move-down" onclick="moveStage(${index}, 1)" ${index === currentFlowDefinition.length - 1 ? 'disabled' : ''} title="ä¸‹ç§»æ­¤éšæ®µ">â†“ ä¸‹ç§»</button>`;
                
                moreActionsContainer.appendChild(dropdownDiv);
                controlsDiv.appendChild(moreActionsContainer);
                                
                li.appendChild(infoOuterDiv); 
                li.appendChild(controlsDiv); 
                flowEditorList.appendChild(li); 
            }); 
            if (sortableInstance) sortableInstance.destroy(); 
            sortableInstance = new Sortable(flowEditorList, { animation: 150, ghostClass: 'sortable-ghost', handle: 'li', onEnd: function (evt) { const oldIndex=parseInt(evt.oldDraggableIndex), newIndex=parseInt(evt.newDraggableIndex); if(oldIndex!==newIndex){ const [movedItem]=currentFlowDefinition.splice(oldIndex, 1); currentFlowDefinition.splice(newIndex, 0, movedItem); renderEditorList();} } }); 
        }
        
        function openEditModal(index, insertBeforeIndexOpt = null) { 
            const isNew = index === -1; 
            currentInsertBeforeIndex = isNew ? insertBeforeIndexOpt : null; 
            modalTitle.textContent = isNew ? (currentInsertBeforeIndex !== null ? `åœ¨éšæ®µ ${currentInsertBeforeIndex + 1} ä¹‹å‰æ–°å¢` : "æ–°å¢éšæ®µ (æœ«å°¾)") : `ç·¨è¼¯éšæ®µ ${index + 1}`; 
            editingStageIndexInput.value = index; 
            if (isNew) { 
                stageNameInput.value = ""; 
                stageTypeSelect.value = "announcement"; 
                stageDurationInput.value = ""; 
                stageTimerLabelInput.value = ""; 
                stageScriptInput.value = ""; 
                stageGraceDurationInput.value = ""; 
                stageGraceEndActionSelect.value = "auto_start"; 
            } else { 
                const stage = currentFlowDefinition[index]; 
                stageNameInput.value = stage.name || ""; 
                stageTypeSelect.value = stage.type || "announcement"; 
                stageDurationInput.value = stage.duration || ""; 
                stageTimerLabelInput.value = stage.timerLabel || ""; 
                stageScriptInput.value = stage.script || ""; 
                stageGraceDurationInput.value = typeof stage.graceDuration === 'number' ? stage.graceDuration : "";
                stageGraceEndActionSelect.value = stage.graceEndAction || "auto_start";
            } 
            handleModalFieldVisibility(); 
            stageEditModal.style.display = "block"; 
            stageNameInput.focus(); 
        }

        function closeModal() { 
            stageEditModal.style.display = "none"; 
            currentInsertBeforeIndex = null; 
            document.querySelectorAll('#flowEditorList .more-actions-dropdown.active').forEach(dropdown => {
                dropdown.classList.remove('active');
            });
        }
        
        function handleModalFieldVisibility() {
            const selectedType = stageTypeSelect.value;
            const needsMainDurationAndLabel = ["manual_prep", "speech_auto"].includes(selectedType);
            const isSpeechAuto = selectedType === "speech_auto";

            timingSettingsFieldset.classList.toggle('hidden', !needsMainDurationAndLabel && !isSpeechAuto); 

            if (!timingSettingsFieldset.classList.contains('hidden')) {
                durationInputContainer.classList.toggle('hidden', !needsMainDurationAndLabel);
                timerLabelInputContainer.classList.toggle('hidden', !needsMainDurationAndLabel);
                graceDurationInputContainer.classList.toggle('hidden', !isSpeechAuto);
            } else {
                durationInputContainer.classList.add('hidden');
                timerLabelInputContainer.classList.add('hidden');
                graceDurationInputContainer.classList.add('hidden');
            }
            speechAutoSettingsFieldset.classList.toggle('hidden', !isSpeechAuto);
        }
        stageTypeSelect.addEventListener('change', handleModalFieldVisibility); 
        
        function saveStageChanges() { 
            const index = parseInt(editingStageIndexInput.value); 
            const isNew = index === -1; 
            const stageData = { 
                name: stageNameInput.value.trim() || (isNew ? "æ–°éšæ®µ" : `éšæ®µ ${index + 1}`), 
                type: stageTypeSelect.value, 
                script: stageScriptInput.value.trim(), 
                duration: null, 
                timerLabel: null,
                graceDuration: null, 
                graceEndAction: 'auto_start' 
            }; 
            
            if (["manual_prep", "speech_auto"].includes(stageData.type)) { 
                const duration = parseInt(stageDurationInput.value); 
                stageData.duration = isNaN(duration) || duration < 1 ? 60 : duration; 
                stageData.timerLabel = stageTimerLabelInput.value.trim() || null; 
            } 
            
            if (stageData.type === "speech_auto") {
                const graceDur = parseInt(stageGraceDurationInput.value);
                stageData.graceDuration = (stageGraceDurationInput.value.trim() === "" || isNaN(graceDur) || graceDur < 0) 
                                          ? DEFAULT_GRACE_PERIOD_DURATION 
                                          : graceDur;
                stageData.graceEndAction = stageGraceEndActionSelect.value || 'auto_start';
            } else {
                stageData.graceDuration = null;
                stageData.graceEndAction = null;
            }

            if (isNew) {
                if (currentInsertBeforeIndex !== null) {
                    currentFlowDefinition.splice(currentInsertBeforeIndex, 0, stageData);
                } else {
                    currentFlowDefinition.push(stageData); 
                }
            } else { 
                currentFlowDefinition[index] = stageData; 
            } 
            renderEditorList(); 
            closeModal(); 
        }
        
        function duplicateStage(index) {
            if (index < 0 || index >= currentFlowDefinition.length) return;
            const originalStage = currentFlowDefinition[index];
            const duplicatedStage = JSON.parse(JSON.stringify(originalStage)); 
            duplicatedStage.name = (duplicatedStage.name || "è¤‡è£½çš„éšæ®µ") + " (å‰¯æœ¬)";
            currentFlowDefinition.splice(index + 1, 0, duplicatedStage);
            renderEditorList();
        }

        function deleteStage(index) { if (confirm(`ç¢ºå®šè¦åˆªé™¤éšæ®µ ${index + 1} (${currentFlowDefinition[index].name}) å—ï¼Ÿ`)) { currentFlowDefinition.splice(index, 1); renderEditorList(); } }
        function moveStage(index, direction) { 
            if (direction === -1 && index > 0) { 
                [currentFlowDefinition[index], currentFlowDefinition[index - 1]] = [currentFlowDefinition[index - 1], currentFlowDefinition[index]]; 
            } else if (direction === 1 && index < currentFlowDefinition.length - 1) { 
                [currentFlowDefinition[index], currentFlowDefinition[index + 1]] = [currentFlowDefinition[index + 1], currentFlowDefinition[index]]; 
            } 
            renderEditorList(); 
        }

        function loadStage(index) { 
            const stage = currentFlowDefinition[index]; 
            if (!stage) return; 
            const endedStageIndex = currentStageIndex; // Keep track of the stage we are leaving
            currentStageIndex = index; // Update to the new stage index

            currentStageInfoDisplay.textContent = `${stageIcons[stage.type] || ''} ç›®å‰éšæ®µï¼š${interpolateScript(stage.name)}`; 
            moderatorScriptDisplay.textContent = interpolateScript(stage.script); 
            clearAllTimersAndIntervals(); 
            manualStartTimerButton.classList.add('hidden'); 
            speechRecognitionStatusDisplay.textContent = ""; 
            speechRecognitionStatusDisplay.classList.add('hidden'); 
            drawRebuttalOrderSection.classList.add('hidden'); 
            timerDisplay.classList.add('hidden'); 
            timerProgressBarContainer.classList.add('hidden'); 
            timerStatusDisplay.textContent = ""; 
            nextStageButton.disabled = false; 
            forceStartMainTimerButton.textContent = "å¼·åˆ¶é–‹å§‹ç™¼è¨€è¨ˆæ™‚"; 
            
            if (currentStageIndex + 1 < currentFlowDefinition.length) {
                const nextStageDetails = currentFlowDefinition[currentStageIndex + 1];
                nextSegmentPreview.textContent = `ä¸‹ä¸€ç’°ç¯€ï¼š${interpolateScript(nextStageDetails.name)}`;
                nextSegmentPreview.classList.remove('hidden');
            } else {
                nextSegmentPreview.textContent = "æœ€å¾Œç’°ç¯€"; 
                nextSegmentPreview.classList.remove('hidden'); 
            }
            
            const isFullscreen = document.body.classList.contains('fullscreen-active');
            let defaultTimerColor = isFullscreen ? '#259DFA' : getComputedStyle(document.documentElement).getPropertyValue('--color-primary').trim();
            timerDisplay.style.color = defaultTimerColor; 
            timerProgressBar.style.backgroundColor = defaultTimerColor; 
            if (isFullscreen) timerProgressBar.removeAttribute('data-color-state');


            speak(interpolateScript(stage.script), () => { 
                if (stage.type === "speech_auto") { 
                    startGracePeriodTimer(); 
                } else if (stage.type === "manual_prep") { 
                    manualStartTimerButton.classList.remove('hidden'); 
                    manualStartTimerButton.disabled = false; 
                    manualStartTimerButton.textContent = `é–‹å§‹${stage.timerLabel || 'è¨ˆæ™‚'}`; 
                    timerDisplay.classList.remove('hidden'); 
                    timerProgressBarContainer.classList.remove('hidden'); 
                    initialTimerDuration = stage.duration; 
                    updateProgressBar(stage.duration, stage.duration); 
                    timerStatusDisplay.textContent = (stage.timerLabel || "è¨ˆæ™‚") + "æº–å‚™é–‹å§‹..."; 
                    updateTimerDisplayDOM(stage.duration); 
                } else if (stage.type === "draw_rebuttal_order") { 
                    drawRebuttalOrderSection.classList.remove('hidden'); 
                    drawResultDisplay.textContent = "å¾…æŠ½ç±¤..."; 
                    startDrawButton.disabled = false; 
                    nextStageButton.disabled = true; 
                } else { // Handles 'announcement' and any other non-timed types
                    timerDisplay.classList.add('hidden'); 
                    timerProgressBarContainer.classList.add('hidden');
                    timerStatusDisplay.textContent = ""; 
                    if (currentStageIndex >= currentFlowDefinition.length -1) { // Use currentStageIndex
                        nextStageButton.disabled = true;
                        nextSegmentPreview.textContent = "è¾¯è«–å·²çµæŸ"; 
                    } else {
                        if (isAutoModeEnabled) { // Check auto mode for announcements
                            setTimeout(() => {
                                // Ensure we are still on this announcement stage and not paused or reset
                                if (currentStageIndex === index && !isTimerPaused && !timerInterval && !graceTimerInterval) { 
                                     loadNextStage();
                                }
                            }, 2000); // 2-second delay
                        } else {
                            nextStageButton.disabled = false; 
                        }
                    }
                } 
            }); 
        }
        function loadNextStage() { 
            //This function is now only responsible for incrementing and loading the next stage's base state.
            //It should not call itself recursively or manage timers directly.
            //The decision to call loadNextStage should be made externally (e.g., button click, timer end + auto mode).
            
            const previousStageIndex = currentStageIndex;
            const nextIndex = previousStageIndex + 1;

            stopRecognitionForce(); 
            clearAllTimersAndIntervals(); 
            
            if (nextIndex < currentFlowDefinition.length) { 
                playSound('stageAdvanceSound'); 
                loadStage(nextIndex); // Directly load the new stage by its index
                
                const nextStageData = currentFlowDefinition[nextIndex]; 
                const isFullscreen = document.body.classList.contains('fullscreen-active');
                let defaultTimerColor = isFullscreen ? '#259DFA' : getComputedStyle(document.documentElement).getPropertyValue('--color-primary').trim();

                if (nextStageData?.type === 'speech_auto') { 
                    const graceDur = (typeof nextStageData.graceDuration === 'number' && nextStageData.graceDuration >=0) ? nextStageData.graceDuration : DEFAULT_GRACE_PERIOD_DURATION;
                    timerDisplay.textContent = formatTime(graceDur); 
                    timerDisplay.style.color = defaultTimerColor;
                } else if (nextStageData?.duration && nextStageData?.type === 'manual_prep') { 
                    timerDisplay.textContent = formatTime(nextStageData.duration); 
                    timerDisplay.style.color = defaultTimerColor;
                } else {
                     timerProgressBarContainer.classList.add('hidden'); 
                }
            } else { 
                // This is the end of the flow. Update currentStageIndex to reflect this.
                currentStageIndex = nextIndex; // currentStageIndex will be >= currentFlowDefinition.length
                currentStageInfoDisplay.textContent = "æ‰€æœ‰æµç¨‹å·²çµæŸã€‚"; 
                nextStageButton.disabled = true; 
                clearAllTimersAndIntervals(); 
                nextSegmentPreview.textContent = "è¾¯è«–å·²çµæŸ";
                nextSegmentPreview.classList.remove('hidden');
            } 
        }
        
        function applyTheme(theme) {
            if (theme === 'dark') {
                bodyElement.classList.add('dark-mode');
                themeToggleButton.textContent = 'åˆ‡æ›æ·ºè‰²æ¨¡å¼';
            } else {
                bodyElement.classList.remove('dark-mode');
                themeToggleButton.textContent = 'åˆ‡æ›æ·±è‰²æ¨¡å¼';
            }
             handleFullscreenChange(); 
        }

        function toggleTheme() {
            let newTheme;
            if (bodyElement.classList.contains('dark-mode')) {
                newTheme = 'light';
            } else {
                newTheme = 'dark';
            }
            applyTheme(newTheme);
            localStorage.setItem('debateTimerTheme', newTheme);
        }

        function showShortcutHelpModal() {
            shortcutHelpModal.style.display = "block";
        }
        function closeShortcutHelpModal() {
            shortcutHelpModal.style.display = "none";
        }

        function updateRealTimeClock() {
            if (fullscreenRealTimeClock) {
                const now = new Date();
                const hours = now.getHours().toString().padStart(2, '0');
                const minutes = now.getMinutes().toString().padStart(2, '0');
                const seconds = now.getSeconds().toString().padStart(2, '0');
                fullscreenRealTimeClock.textContent = `${hours}:${minutes}:${seconds}`;
            }
        }

        function handleOrientationChange() {
            if (screen.orientation && screen.orientation.type) {
                const isLandscape = screen.orientation.type.includes('landscape');
                const isLikelyMobile = window.innerWidth < 800; 
                const isCurrentlyFullscreen = !!document.fullscreenElement;

                if (isLandscape && isLikelyMobile && !isCurrentlyFullscreen) {
                    console.log("Attempting auto-fullscreen on landscape...");
                    document.documentElement.requestFullscreen().catch(err => { 
                        console.warn(`Auto-fullscreen failed: ${err.message}. User interaction might be required first.`); 
                    });
                } else if (!isLandscape && isCurrentlyFullscreen) {
                     console.log("Attempting to exit fullscreen on portrait...");
                     if (document.exitFullscreen) {
                         document.exitFullscreen().catch(err => console.warn(`Exiting fullscreen failed: ${err.message}`));
                     }
                }
            }
        }


        function populateFormatSelector() { 
            for (const formatName in debateFormatDefinitions) { 
                const option = document.createElement('option'); 
                option.value = formatName; 
                option.textContent = formatName; 
                formatSelect.appendChild(option); 
            } 
        }
        window.addEventListener('DOMContentLoaded', () => { 
            populateFormatSelector(); 
            if (!SpeechRecognition) { 
                alert("ç€è¦½å™¨ä¸æ”¯æ´ SpeechRecognition API"); 
            } 
            nextSegmentPreview.classList.add('hidden'); 
            timerProgressBarContainer.classList.add('hidden'); 
            fullscreenRealTimeClock.classList.add('hidden'); 
            
            const savedTheme = localStorage.getItem('debateTimerTheme');
            if (savedTheme) {
                applyTheme(savedTheme);
            } else {
                if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                    applyTheme('dark');
                } else {
                    applyTheme('light'); 
                }
            }

            // Initialize Auto Mode
            const savedAutoMode = localStorage.getItem('debateAutoMode');
            if (savedAutoMode === 'true') {
                isAutoModeEnabled = true;
                autoModeToggle.checked = true;
            } else {
                isAutoModeEnabled = false;
                autoModeToggle.checked = false;
            }
            autoModeToggle.addEventListener('change', (event) => {
                isAutoModeEnabled = event.target.checked;
                localStorage.setItem('debateAutoMode', isAutoModeEnabled);
            });


            if(themeToggleButton) { 
                 themeToggleButton.addEventListener('click', toggleTheme);
            }
            if(shortcutHelpCloseButton) { 
                shortcutHelpCloseButton.addEventListener('click', closeShortcutHelpModal);
            }
            addStageButton.addEventListener('click', () => openEditModal(-1)); 
            
            if (screen.orientation && typeof screen.orientation.addEventListener === 'function') {
                 screen.orientation.addEventListener('change', handleOrientationChange);
            } else {
                console.warn("Screen Orientation API not fully supported, landscape auto-fullscreen might not work.");
            }

            document.body.addEventListener('click', function(event) {
                let isMoreActionsButton = event.target.classList.contains('more-actions-btn') || (event.target.parentElement && event.target.parentElement.classList.contains('more-actions-btn'));
                let targetIsInsideDropdown = false;
                document.querySelectorAll('#flowEditorList .more-actions-dropdown').forEach(dropdown => {
                    if (dropdown.contains(event.target)) {
                        targetIsInsideDropdown = true;
                    }
                });

                if (!isMoreActionsButton && !targetIsInsideDropdown) {
                    document.querySelectorAll('#flowEditorList .more-actions-dropdown.active').forEach(openDropdown => {
                        openDropdown.classList.remove('active');
                    });
                }
            });
        });

        editFlowButton.addEventListener('click', () => { const selectedFormatName = formatSelect.value; let flowToEdit; if (debateFormatDefinitions[selectedFormatName]) { flowToEdit = JSON.parse(JSON.stringify(debateFormatDefinitions[selectedFormatName])); } else { alert("è«‹å…ˆé¸æ“‡ä¸€å€‹æœ‰æ•ˆçš„æµç¨‹ç¯„æœ¬ï¼"); return; } originalFlowBeforeEdit = JSON.parse(JSON.stringify(flowToEdit)); currentFlowDefinition = flowToEdit; setupPhaseDiv.classList.add('hidden'); flowEditorSection.classList.remove('hidden'); renderEditorList(); });
        cancelEditingButton.addEventListener('click', () => { if (confirm("å–æ¶ˆç·¨è¼¯ï¼Ÿæ‰€æœ‰æœªå„²å­˜çš„è®Šæ›´å°‡æœƒéºå¤±ã€‚")) { flowEditorSection.classList.add('hidden'); setupPhaseDiv.classList.remove('hidden'); currentFlowDefinition = originalFlowBeforeEdit ? JSON.parse(JSON.stringify(originalFlowBeforeEdit)) : []; originalFlowBeforeEdit = null; formatSelect.value = formatSelect.options[0].value; } });
        finishEditingButton.addEventListener('click', () => { const baseName = formatSelect.value.replace(" (è‡ªè¨‚)", "").replace(/\(åŒ¯å…¥\)\s*/, ""); const editedFlowName = baseName + " (è‡ªè¨‚)"; debateFormatDefinitions[editedFlowName] = JSON.parse(JSON.stringify(currentFlowDefinition)); let existingOption = false; for(let i=0; i < formatSelect.options.length; i++) { if(formatSelect.options[i].value === editedFlowName) { existingOption = true; break; } } if (!existingOption) { const option = document.createElement('option'); option.value = editedFlowName; option.textContent = editedFlowName; formatSelect.appendChild(option); } formatSelect.value = editedFlowName; flowEditorSection.classList.add('hidden'); setupPhaseDiv.classList.remove('hidden'); alert(`æµç¨‹ "${editedFlowName}" å·²å„²å­˜ä¸¦é¸å–ã€‚`); originalFlowBeforeEdit = null; });
        
        confirmSetupButton.addEventListener('click', () => { 
            const selectedFormatName = formatSelect.value; 
            if (currentFlowDefinition && currentFlowDefinition.length > 0 && (formatSelect.value.includes("(è‡ªè¨‚)") || formatSelect.value.startsWith("(åŒ¯å…¥)"))) {
                 console.log("Using pre-loaded/edited flow for:", selectedFormatName);
            } else if (debateFormatDefinitions[selectedFormatName]) { 
                currentFlowDefinition = JSON.parse(JSON.stringify(debateFormatDefinitions[selectedFormatName])); 
            } else { 
                alert("ç„¡æ³•è¼‰å…¥æ‰€é¸æµç¨‹ï¼è«‹ç¢ºèªé¸æ“‡æˆ–åŒ¯å…¥æµç¨‹ã€‚"); 
                return; 
            }

            positiveTeamName = positiveTeamNameInput.value.trim() || "æ­£æ–¹"; 
            negativeTeamName = negativeTeamNameInput.value.trim() || "åæ–¹"; 
            debateTopic = debateTopicInput.value.trim() || "ï¼ˆæœªè¨­å®šè¾¯é¡Œï¼‰"; 
            debateInfoDisplay.innerHTML = `<p><strong>æµç¨‹ï¼š</strong>${selectedFormatName.replace("(è‡ªè¨‚)","").replace("(åŒ¯å…¥) ","")}</p><p><strong>è¾¯é¡Œï¼š</strong>${debateTopic}</p><p><strong>æ­£æ–¹ï¼š</strong>${positiveTeamName} vs <strong>åæ–¹ï¼š</strong>${negativeTeamName}</p>`; 
            setupPhaseDiv.classList.add('hidden'); 
            flowEditorSection.classList.add('hidden'); 
            debatePhaseDiv.classList.remove('hidden'); 
            nextStageButton.classList.remove('hidden'); 
            resetButton.classList.remove('hidden'); 
            currentStageIndex = -1; 
            rebuttalOrder = null; 
            loadNextStage(); 
        });
        startDrawButton.addEventListener('click', () => { 
            playSound('drawSound'); 
            rebuttalOrder = Math.random() < 0.5 ? 'positive_first' : 'negative_first'; 
            const resultText = `æŠ½ç±¤çµæœï¼š${rebuttalOrder === 'positive_first' ? positiveTeamName : negativeTeamName} å…ˆçµè¾¯ã€‚`; 
            drawResultDisplay.textContent = resultText; 
            speak(resultText, () => {
                if (isAutoModeEnabled && currentStageIndex < currentFlowDefinition.length - 1) {
                    setTimeout(() => {
                        if (currentStageIndex === currentFlowDefinition.findIndex(s => s.type === 'draw_rebuttal_order') && !isTimerPaused ) { // Check if still on draw stage
                            loadNextStage();
                        }
                    }, 2000);
                } else {
                    nextStageButton.disabled = false;
                }
            }); 
            startDrawButton.disabled = true; 
        });
        nextStageButton.addEventListener('click', () => { if (synth.speaking) synth.cancel(); loadNextStage(); });
        manualStartTimerButton.addEventListener('click', () => { const stage = currentFlowDefinition[currentStageIndex]; if (stage && stage.type === "manual_prep") startManualPrepTimer(stage.duration); });
        
        forceStartMainTimerButton.addEventListener('click', () => { 
            const currentStage = currentFlowDefinition[currentStageIndex];
            if (currentTimerType === 'grace' && timeLeft > 0) { 
                if (graceTimerInterval) {
                    clearTimeout(graceTimerInterval); 
                    graceTimerInterval = null; 
                }
                stopRecognitionForce(); 
                timerStatusDisplay.textContent = "æ‰‹å‹•å•Ÿå‹•..."; 
                speak("æ‰‹å‹•å•Ÿå‹•ï¼Œè¨ˆæ™‚é–‹å§‹ã€‚", () => { 
                    startMainSpeechTimer(currentStage.duration); 
                    pauseResumeTimerButton.classList.remove('hidden'); 
                    pauseResumeTimerButton.textContent = "æš«åœè¨ˆæ™‚"; 
                    skipStageButton.classList.add('hidden');
                }); 
                mainSpeechTimerStartedByGrace = true; 
            } else if (currentStage && currentStage.type === 'speech_auto' && currentStage.graceEndAction === 'manual_start' && (currentTimerType === 'grace' || !currentTimerType) && timeLeft <= 0 && !mainSpeechTimerStartedByGrace) {
                timerStatusDisplay.textContent = "æ‰‹å‹•å•Ÿå‹•ä¸»è¦è¨ˆæ™‚...";
                speak("æ‰‹å‹•å•Ÿå‹•ï¼Œè¨ˆæ™‚é–‹å§‹ã€‚", () => {
                    startMainSpeechTimer(currentStage.duration);
                    pauseResumeTimerButton.classList.remove('hidden');
                    pauseResumeTimerButton.textContent = "æš«åœè¨ˆæ™‚";
                    skipStageButton.classList.add('hidden'); 
                    forceStartMainTimerButton.classList.add('hidden'); 
                });
                mainSpeechTimerStartedByGrace = true; 
            }
        });

        exportFlowButton.addEventListener('click', () => { const selectedFormatName = formatSelect.value; let flowToExport = null; let flowName = selectedFormatName; if(currentFlowDefinition && currentFlowDefinition.length > 0 && (selectedFormatName.includes("(è‡ªè¨‚)") || selectedFormatName.startsWith("(åŒ¯å…¥)"))) { flowToExport = currentFlowDefinition; flowName = selectedFormatName; console.log("Exporting currentFlowDefinition for custom/imported flow"); } else if (debateFormatDefinitions[selectedFormatName]) { flowToExport = debateFormatDefinitions[selectedFormatName]; flowName = selectedFormatName; console.log("Exporting from debateFormatDefinitions"); } if (!flowToExport || flowToExport.length === 0) { alert("æ²’æœ‰å¯åŒ¯å‡ºçš„æµç¨‹ï¼è«‹å…ˆé¸æ“‡æˆ–ç·¨è¼¯ä¸€å€‹æœ‰æ•ˆçš„æµç¨‹ã€‚"); return; } const jsonString = JSON.stringify(flowToExport, null, 2); const blob = new Blob([jsonString], { type: 'application/json' }); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; const fileName = flowName.replace(/[\s()]/g, '_').replace('(åŒ¯å…¥)_', 'Imported_').replace('_(è‡ªè¨‚)','_Custom') + ".json"; a.download = fileName; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url); fileImportStatus.textContent = `æµç¨‹ "${flowName}" å·²åŒ¯å‡ºç‚º ${fileName}`; });
        importFlowInput.addEventListener('change', (event) => { const file = event.target.files[0]; if (!file) { fileImportStatus.textContent = "æœªé¸æ“‡æª”æ¡ˆã€‚"; loadImportedFlowButton.classList.add('hidden'); return; } if (file.type !== "application/json") { fileImportStatus.textContent = "éŒ¯èª¤ï¼šè«‹é¸æ“‡ .json æª”æ¡ˆã€‚"; loadImportedFlowButton.classList.add('hidden'); importedDebateStages = null; importFlowInput.value = ""; return; } const reader = new FileReader(); reader.onload = (e) => { try { const parsedFlow = JSON.parse(e.target.result); if (Array.isArray(parsedFlow) && parsedFlow.length > 0 && parsedFlow.every(stage => stage.name && stage.type)) { importedDebateStages = parsedFlow; importedDebateStages.fileName = file.name.replace(/\.json$/i, ""); fileImportStatus.textContent = `æª”æ¡ˆ "${file.name}" å·²æˆåŠŸè®€å–ã€‚`; loadImportedFlowButton.classList.remove('hidden'); loadImportedFlowButton.textContent = `è¼‰å…¥ "${importedDebateStages.fileName}" ä¸¦è¨­ç‚ºç›®å‰æµç¨‹`; } else { throw new Error("JSON çµæ§‹ä¸ç¬¦æˆ–å…§å®¹ä¸å®Œæ•´ã€‚"); } } catch (error) { console.error("Error parsing JSON:", error); fileImportStatus.textContent = `éŒ¯èª¤ï¼šç„¡æ³•è§£ææª”æ¡ˆã€‚${error.message}`; loadImportedFlowButton.classList.add('hidden'); importedDebateStages = null; } }; reader.onerror = () => { fileImportStatus.textContent = "è®€å–æª”æ¡ˆéŒ¯èª¤ã€‚"; loadImportedFlowButton.classList.add('hidden'); importedDebateStages = null; }; reader.readAsText(file); });
        loadImportedFlowButton.addEventListener('click', () => { if (importedDebateStages) { const importName = `(åŒ¯å…¥) ${importedDebateStages.fileName || "è‡ªè¨‚æµç¨‹"}`; debateFormatDefinitions[importName] = JSON.parse(JSON.stringify(importedDebateStages)); 
            currentFlowDefinition = JSON.parse(JSON.stringify(importedDebateStages)); 
            let existingOption = false; for(let i=0; i < formatSelect.options.length; i++) { if(formatSelect.options[i].value === importName) { existingOption = true; break; } } if (!existingOption) { const option = document.createElement('option'); option.value = importName; option.textContent = importName; formatSelect.appendChild(option); } formatSelect.value = importName; fileImportStatus.textContent = `æµç¨‹ "${importName}" å·²æ–°å¢è‡³é¸å–®ã€é¸å–ä¸¦è¼‰å…¥ç‚ºç›®å‰æµç¨‹ã€‚`; loadImportedFlowButton.classList.add('hidden'); importedDebateStages = null; 
            originalFlowBeforeEdit = JSON.parse(JSON.stringify(currentFlowDefinition)); 
        } else { fileImportStatus.textContent = "æ²’æœ‰å¯è¼‰å…¥çš„åŒ¯å…¥æµç¨‹ã€‚"; }});
        resetButton.addEventListener('click', () => { 
            if(!confirm("ç¢ºå®šè¦é‡ç½®æ‰€æœ‰è¨­å®šä¸¦è¿”å›åˆå§‹ç•«é¢å—ï¼Ÿ")) return; 
            stopRecognitionForce(); 
            if (synth.speaking) synth.cancel(); 
            clearAllTimersAndIntervals(); 
            currentStageIndex = -1; 
            rebuttalOrder = null; 
            currentFlowDefinition = []; 
            originalFlowBeforeEdit = null; 
            moderatorScriptDisplay.textContent = "è«‹æŒ‰ã€Œç¢ºèªè¨­å®šã€é–‹å§‹ã€‚"; 
            currentStageInfoDisplay.textContent = ""; 
            timerDisplay.classList.add('hidden'); 
            timerStatusDisplay.textContent = ""; 
            drawResultDisplay.textContent = ""; 
            timerDisplay.textContent = "00:00"; 
            
            isAutoModeEnabled = false; // Reset auto mode
            autoModeToggle.checked = false;
            localStorage.setItem('debateAutoMode', 'false');

            const isFullscreen = bodyElement.classList.contains('fullscreen-active');
            const isDarkMode = bodyElement.classList.contains('dark-mode');
            let defaultTimerColorVal = getComputedStyle(document.documentElement).getPropertyValue('--color-primary').trim(); 
            if (isFullscreen) defaultTimerColorVal = '#259DFA';
            else if (isDarkMode) defaultTimerColorVal = getComputedStyle(document.documentElement).getPropertyValue('--color-primary').trim(); 
            timerDisplay.style.color = defaultTimerColorVal; 

            debatePhaseDiv.classList.add('hidden'); 
            drawRebuttalOrderSection.classList.add('hidden'); 
            flowEditorSection.classList.add('hidden'); 
            setupPhaseDiv.classList.remove('hidden'); 
            nextStageButton.classList.add('hidden'); 
            resetButton.classList.add('hidden'); 
            manualStartTimerButton.classList.add('hidden'); 
            forceStartMainTimerButton.classList.add('hidden'); 
            speechRecognitionStatusDisplay.textContent = ""; 
            speechRecognitionStatusDisplay.classList.add('hidden'); 
            pauseResumeTimerButton.classList.add('hidden'); 
            skipStageButton.classList.add('hidden'); 
            nextStageButton.disabled = false; 
            manualStartTimerButton.disabled = false; 
            startDrawButton.disabled = false; 
            debateInfoDisplay.innerHTML = ""; 
            fileImportStatus.textContent = ""; 
            importFlowInput.value=""; 
            loadImportedFlowButton.classList.add('hidden'); 
            importedDebateStages = null; 
            positiveTeamNameInput.value = "æ­£æ–¹"; 
            negativeTeamNameInput.value = "åæ–¹"; 
            debateTopicInput.value = "ï¼ˆåœ¨æ­¤è¼¸å…¥è¾¯é¡Œï¼‰"; 
            if (formatSelect.options.length > 0) formatSelect.selectedIndex = 0; 
            timerProgressBarContainer.classList.add('hidden'); 
            nextSegmentPreview.classList.add('hidden'); 
            nextSegmentPreview.textContent = ""; 
        });

        function toggleFullscreen() { if (!document.fullscreenElement) { document.documentElement.requestFullscreen().catch(err => { alert(`ç„¡æ³•é€²å…¥å…¨è¢å¹•æ¨¡å¼: ${err.message} (${err.name})`); }); } else { if (document.exitFullscreen) { document.exitFullscreen(); } } }
        
        function handleFullscreenChange() { 
            const isCurrentlyFullscreen = !!document.fullscreenElement;
            bodyElement.classList.toggle('fullscreen-active', isCurrentlyFullscreen); 
            fullscreenButton.textContent = isCurrentlyFullscreen ? 'é€€å‡ºå…¨è¢å¹•' : 'é€²å…¥å…¨è¢å¹•'; 
            
            const stage = currentFlowDefinition[currentStageIndex];
            let timerColorToSet;

            if (isCurrentlyFullscreen) {
                fullscreenRealTimeClock.classList.remove('hidden');
                updateRealTimeClock(); 
                if (!realTimeClockInterval) { 
                    realTimeClockInterval = setInterval(updateRealTimeClock, 1000);
                }
                timerColorToSet = '#259DFA'; 
                if (timerDisplay.style.color.startsWith('rgb(255, 165, 0)') || timerDisplay.style.color === 'var(--color-warning)') timerColorToSet = '#FFB84D';
                else if (timerDisplay.style.color.startsWith('rgb(255, 69, 0)') || timerDisplay.style.color === 'var(--color-orange-accent)') timerColorToSet = '#FF6B4D';
                else if (timerDisplay.style.color.startsWith('rgb(220, 53, 69)') || timerDisplay.style.color === 'var(--color-danger)' || timerDisplay.textContent === "æ™‚é–“åˆ°") timerColorToSet = '#F87171';
            } else {
                fullscreenRealTimeClock.classList.add('hidden');
                if (realTimeClockInterval) { 
                    clearInterval(realTimeClockInterval);
                    realTimeClockInterval = null;
                }
                timerColorToSet = getComputedStyle(document.documentElement).getPropertyValue('--color-primary').trim(); 
                 if (timerDisplay.style.color.includes('255, 165, 0') || timerDisplay.style.color.includes('FFB84D')) timerColorToSet = getComputedStyle(document.documentElement).getPropertyValue('--color-warning').trim();
                else if (timerDisplay.style.color.includes('255, 69, 0') || timerDisplay.style.color.includes('FF6B4D')) timerColorToSet = getComputedStyle(document.documentElement).getPropertyValue('--color-orange-accent').trim();
                else if (timerDisplay.style.color.includes('220, 53, 69') || timerDisplay.style.color.includes('F87171') || timerDisplay.textContent === "æ™‚é–“åˆ°") timerColorToSet = getComputedStyle(document.documentElement).getPropertyValue('--color-danger').trim();
            }
             if (!timerDisplay.classList.contains('hidden')) {
                timerDisplay.style.color = timerColorToSet;
            }

            if (initialTimerDuration > 0 && timeLeft !== undefined) { 
                updateProgressBar(timeLeft, initialTimerDuration);
            } else { 
                timerProgressBar.style.backgroundColor = isCurrentlyFullscreen ? '#259DFA' : getComputedStyle(document.documentElement).getPropertyValue('--color-primary').trim();
                if (isCurrentlyFullscreen) timerProgressBar.removeAttribute('data-color-state');
            }
        }
        fullscreenButton.addEventListener('click', toggleFullscreen);
        document.addEventListener('fullscreenchange', handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
        document.addEventListener('mozfullscreenchange', handleFullscreenChange);
        document.addEventListener('MSFullscreenChange', handleFullscreenChange);

        window.addEventListener('keydown', (event) => {
            const activeElement = document.activeElement;
            const isTyping = activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA' || activeElement.tagName === 'SELECT');

            if (event.key === 'Escape') {
                if (shortcutHelpModal.style.display === "block") {
                    closeShortcutHelpModal();
                    event.preventDefault();
                } else if (stageEditModal.style.display === "block") {
                    closeModal(); 
                    event.preventDefault();
                }
                return; 
            }

            if (event.key === '/') {
                if (!isTyping) {
                    if (shortcutHelpModal.style.display === "block") {
                        closeShortcutHelpModal();
                    } else {
                        showShortcutHelpModal();
                    }
                    event.preventDefault();
                }
                return; 
            }
            
            if (isTyping && event.key !== 'Enter' && event.key !== 'Escape' ) return; 

            switch (event.key.toLowerCase()) {
                case 'n':
                case 'arrowright':
                    if (nextStageButton && !nextStageButton.classList.contains('hidden') && !nextStageButton.disabled) {
                        nextStageButton.click();
                        event.preventDefault();
                    }
                    break;
                case 'p':
                case ' ': 
                    if (pauseResumeTimerButton && !pauseResumeTimerButton.classList.contains('hidden')) {
                        pauseResumeTimerButton.click();
                        event.preventDefault();
                    }
                    break;
                case 's':
                    if (manualStartTimerButton && !manualStartTimerButton.classList.contains('hidden') && !manualStartTimerButton.disabled) {
                        manualStartTimerButton.click();
                    } else if (forceStartMainTimerButton && !forceStartMainTimerButton.classList.contains('hidden')) {
                        forceStartMainTimerButton.click();
                    }
                    event.preventDefault();
                    break;
                case 'r':
                    if (resetButton && !resetButton.classList.contains('hidden')) {
                        resetButton.click();
                        event.preventDefault();
                    }
                    break;
                case 'f':
                    if (fullscreenButton) {
                        fullscreenButton.click();
                        event.preventDefault();
                    }
                    break;
                case 't':
                     if (themeToggleButton) {
                        themeToggleButton.click();
                        event.preventDefault();
                    }
                    break;
            }
        });

        window.onclick = function(event) { 
            if (event.target == stageEditModal) { 
                 if (event.target.classList.contains('modal')) { 
                    closeModal(); 
                 }
            } else if (event.target == shortcutHelpModal) { 
                if (event.target.classList.contains('modal')) {
                    closeShortcutHelpModal();
                }
            }
        }

    </script>
    <div id="creditFooter">
        <a href="https://chengsc.pythonanywhere.com/" target="_blank" rel="noopener noreferrer">ç”±å°ç£è¾¯è«–å½©åˆ¸è£½ä½œ</a>
    </div>
</body>
</html>
